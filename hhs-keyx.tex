\documentclass{article}

\usepackage{amssymb, amsmath, amsthm}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{unicode}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[ruled, vlined, linesnumbered]{algorithm2e}
\SetEndCharOfAlgoLine{}
\SetKwInput{Params}{Public parameters}
\SetKwInput{Key}{Shared key}
\SetKwInput{Input}{Input}
\SetKwBlock{Alice}{Alice}{}
\SetKwBlock{Bob}{Bob}{}
\SetKw{Samples}{samples}
\SetKw{Sends}{sends}

%Shortcuts
\newcommand{\F}{\mathbb{F}}
\newcommand{\Fbar}{\overline{\mathbb{F}}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Cl}{\mathcal{C}}
\newcommand{\Graph}{\mathcal{G}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\softO}{\tilde{O}}
\newcommand{\isom}{\overset{\sim}{\longrightarrow}}
\newcommand{\from}{\ensuremath{\,:\ }}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\suchthat}{\,\middle\vert\,}
\newcommand{\algstyle}[1]{\textsc{#1}}
\renewcommand{\v}{\vspace{5mm}}
\renewcommand{\frak}{\mathfrak}
\newcommand{\rand}[1]{\overset{#1}{∈}}
\newcommand{\uni}{\rand{R}}
\newcommand{\Adv}[2][]{\mathsf{Adv}^{#1}_{\text{\rm #2}}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{prob}[theorem]{Problem}
\newtheorem{remark}[theorem]{Remark}

\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Card}{Card}
\DeclareMathOperator{\Ell}{Ell}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\Proba}{Pr}

\title{Towards practical key exchange from ordinary isogeny graphs}
\author{Luca De Feo, Jean Kieffer, Benjamin Smith}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\textbf{Keywords:} Public-key cryptography, elliptic curve isogenies,
complex multiplication, modular curves.

\section{Introduction}
\label{sec:introduction}

A recent trend in cryptography is the development of quantum-safe
cryptosystems: protocols based on mathematical problems not known to
be solvable in polynomial time by quantum computers. With Shor's
algorithm~\cite{shor1994algorithms} ruling out systems based on
integer factorization or discrete logarithms, NIST has launched a
process to standardize the next generation of \emph{post-quantum}
public key cryptosystems~\cite{NIST2016}. In response, NIST has
received 69 proposals, most of them belonging to the three more
popular post-quantum families: lattice-based systems, code-based
systems, and multivariate systems. Among the youngest and least
explored families, \emph{isogeny-based} cryptography features only one
proposal to the NIST competition: the Supersingular Isogeny Key
Encapsulation (SIKE)~\cite{SIKE}.

SIKE is based upon the key-exchange protocol by Jao and De
Feo~\cite{jao+defeo2011}, known as SIDH, itself inspired by earlier
key-exchange constructions by Couveignes~\cite{cryptoeprint:2006:291}
and Rostovtsev and
Stolbunov~\cite{rostovtsev+stolbunov06,stolbunov-red,Stol}. The
origins of isogeny-based cryptography can be traced back to
Couveignes' seminal work ``Hard Homogeneous Spaces'', that went
unpublished for ten years before appearing
in~\cite{cryptoeprint:2006:291}. Let $G$ be a group, a \emph{principal
  homogeneous space} for $G$ is a set $X$ with an
action of $G$ on $X$ such that for any $x∈X$ the map $φ_x:g↦g·x$ is an
isomorphism between $G$ and $X$. Intuitively, one can think of $X$ as
a \emph{copy} (or, rather, \emph{many different copies}) of $G$ where
the information on the identity element has been forgotten. Couveignes
defines a \emph{hard homogeneous space} (HHS) to be a principal
homogeneous space where computing
the action of $G$ on $X$ is computationally feasible, but inverting
the isomorphism $φ_x$ is computationally hard for any $x$.

\begin{algorithm}
  \caption{Generic key exchange from a hard homogeneous space}
  \label{proto:hhs}
  \Params{A \emph{base point} $x_0∈X$}
  \Alice{
    \Samples a random element $a∈G$\;
    \Sends $x_a = a·x_0$ to Bob}
  \Bob{
    \Samples a random element $b∈G$\;
    \Sends $x_b = b·x_0$ to Alice}
  \Key{$a·x_b = b·x_a = ab·x_0$}
\end{algorithm}

Any HHS $X$ for a finite Abelian group $G$ can be used to construct a
key exchange as shown in Algorithm~\ref{proto:hhs}.  If $X$ is a
cyclic group $〈x〉$ of order $p$, and $G=ℤ/pℤ$ acting on $X$ by
$g·x=x^g$, then this is simply the Diffie--Hellman key exchange, and
inverting $φ_x$ is the discrete logarithm problem (DLP) in $X$.  But,
for other homogeneous spaces, inverting $φ_x$ may have no relationship
with a DLP, and may potentially be harder to solve, including for a
quantum computer. Similar ideas have repeatedly appeared in the
literature under different
flavors~\cite{10.1007/3-540-44598-6_10,monico2007}.

Couveignes viewed HHS chiefly as a general framework, encompassing
various flavors of Diffie--Hellman-like systems. Nevertheless, he
suggested using a specific HHS based on the theory of complex
multiplication of elliptic curves, in a sense generalizing to the HHS
framework the class-group-based Diffie--Hellman key exchange of
Buchmann and Williams~\cite{Buchmann1988}. Independently, Rostovtsev
and Stolbunov proposed in~\cite{rostovtsev+stolbunov06} a public key
encryption scheme based on the same HHS. Later, Stolbunov~\cite{Stol}
derived more protocols from their primitive, including an interactive
key exchange scheme similar to Algorithm~\ref{proto:hhs}.  Rostovtsev
and Stolbunov's proposal crucially deviates from the HHS paradigm in
the way random elements of $G$ are sampled, as we will explain in
Section~\ref{sec:keyex}. This makes the primitive less flexible, but
also (relatively) more practical.

Rostovtsev and Stolbunov advertised their protocols as a potential
post-quantum candidates, leading Childs, Jao and Soukharev to introduce
the first subexponential quantum algorithm capable of breaking
them~\cite{childs2014constructing}. Hence, being already slow enough to
be impractical in a classical security setting, the
Rostovtsev--Stolbunov primitive became even more unusable in a quantum
security setting. This led Jao and De Feo to create the SIDH
key-exchange protocol~\cite{jao+defeo2011}, which to the present day
is not victim to any subexponential attack.

The aim of the present paper is to improve and modernize the
Couveignes--Rostovtsev--Stolbunov (CRS) construction, borrowing
techniques from SIDH and point-counting algorithms, to the point of
making it usable in a post-quantum setting.  Our main contributions
are in Sections~\ref{sec:keyex}--\ref{sec:initcurve}, where we present
a new, more efficient way of computing the CRS group action, and in
Section~\ref{sec:sec} where we give precise classic and quantum
security estimates, we formalize hardness assumptions, and sketch
security proofs in models stronger than what was previously
considered.

Although the final result is far from being practical, we believe it
constitutes progress in the direction of having a valid isogeny-based
alternative to SIDH.  Furthermore, the CRS primitive presents some
distinct advantages over SIDH, that we shall discuss in
Section~\ref{sec:sec}. While preparing this paper we were informed of
a recent work by Castryk, Lange, Martindale, Panny and Renes,
introducing an efficient post-quantum primitive very similar to
CRS~\cite{csidh}.  Their work builds upon the ideas presented in
Sections~\ref{sec:keyex}--\ref{sec:initcurve}, and uses them in a
different homogeneous space where they apply effortlessly.  Their
breakthrough confirms that, if anything, our techniques were a
fundamental step towards the first practical post-quantum
non-interactive key exchange protocol.

The paper is structured as follows. In Section~\ref{sec:math} we
review the fundamental mathematical concepts underlying the CRS group
action, in Sections~\ref{sec:keyex}--\ref{sec:sec} we present our main
contributions, finally in Section~\ref{sec:exp} we present a
proof-of-concept implementation and measure its performance.

\section{Isogenies and complex multiplication}
\label{sec:math}

We recall here basic facts on isogenies of elliptic curves defined
over finite fields. For an in-depth introduction to these concepts, we
refer the reader to~\cite{silverman:elliptic}. For a general
overview of isogenies and their use in cryptography, we
suggest~\cite{defeo2017isogenybased}.

In what follows $\F_q$ is a finite field of characteristic $p$ with
$q$ elements, and $\Fbar_q$ is its algebraic closure. Let $E$ and $E'$
be elliptic curves defined over $\F_q$. 
A homomorphism $ϕ:E→E'$ is an
algebraic map sending $0_E$ to $0_{E'}$;
it induces a group homomomorphism from
$E(\Fbar_q)$ to $E'(\Fbar_q)$~\cite[III.4]{silverman:elliptic}.
An \emph{endomorphism} is a homomorphism from a curve to itself.
The endomorphisms of $E$ form a ring $\End(E)$,
with the group law on $E$ for addition
and composition for multiplication.
The simplest examples of endomorphisms
are the scalar multiplications $[m]$
(mapping $P$ to the sum of $m$ copies of $P$)
and the \emph{Frobenius} endomorphism
\begin{align*}
  π : E &\longrightarrow E \,, \\
  (x,y) &\longmapsto (x^q,y^q) \,.
\end{align*}
As an element of $\End(E)$, Frobenius satisfies a quadratic equation
$π^2 + q = tπ$.  The integer $t$ (the \emph{trace})
fully determines the order of $E$ as $\#E(\F_q)=q+1-t$. A curve is
called \emph{supersingular} if $p$ divides $t$, \emph{ordinary}
otherwise.

An \emph{isogeny} is a non-zero homomorphism of elliptic curves.
The
degree of an isogeny is its degree as an algebraic map,
so for example the Frobenius endomorphism $\pi$ has degree $q$,
and the scalar multiplication $[m]$ has degree $m^2$.
Isogenies of degree $ℓ$ are called $ℓ$-isogenies.
The kernel $\ker ϕ$ of $\phi$
is the subgroup of $E(\Fbar_q)$ that is
mapped to $0_{E'}$. 
An isogeny $ϕ$ is \emph{cyclic} 
if $\ker ϕ$ is a cyclic group.

Any isogeny can be factored as a composition of a \emph{separable} and
a \emph{purely inseparable} isogeny. \emph{Purely inseparable}
isogenies have trivial kernel, and degree a power of $p$.
\emph{Separable} isogenies include all
isogenies of degree coprime to $p$.
Up to isomorphism, separable isogenies
are in one-to-one correspondence with their kernels:
for any finite subgroup $G⊂E$ of order $ℓ$ there is 
an elliptic curve $E/G$ and an $\ell$-isogeny $\phi: E \to E/G$
such that $\ker \phi = G$,
and the curve and isogeny are unique up to isomorphism.
In particular, if $\phi$ is separable then $\deg ϕ=\#\ker ϕ$.
It follows
that any isogeny of degree greater than $1$ can be factored as a
composition of cyclic isogenies of prime degree.

For any $ℓ$-isogeny $ϕ:E→E'$, there is a unique $ℓ$-isogeny
$\hat{ϕ}:E'→E$ such that $ϕ∘\hat{ϕ} = [\ell]$ on $E'$
and $\hat{ϕ}∘ϕ = [\ell]$ on $E$.
We call $\hat{ϕ}$ the \emph{dual} of $ϕ$. This
shows that being \emph{$\ell$-isogenous} is an equivalence
relation. Further, a theorem of Tate states that two curves are
isogenous over $\F_q$ if and only if they have the same number of
points over $\F_q$.


\subsection{Isogeny graphs}
\label{sec:isogeny-graphs}

In isogeny-based cryptography one is mostly interested in
\emph{isogeny graphs}: (multi)-graphs whose vertices are
elliptic curves up to isomorphism, and whose edges are isogenies
between them (again up to isomorphism).
%Because of the dual isogeny theorem, isogeny graphs are typically
%considered undirected.  %% BS: removed this sentence because we never use it.
The use of isogeny graphs for algorithmic applications 
goes back to Mestre and Oesterlé~\cite{Mestre},
followed notably by Kohel~\cite{kohel},
and has been continued by many
authors~\cite{Gal,fouquet+morain02,GHS,MiretMSTV06,jao+miller+venkatesan09}.

We write $E[ℓ]$ for the subgroup of $ℓ$-torsion points of
$E(\Fbar_q)$.  If $ℓ$ is coprime to $p$, then $E[ℓ]$ is isomorphic to
$(ℤ/ℓℤ)^2$.  Furthermore, if $ℓ$ is prime then $E[ℓ]$ contains exactly
$ℓ+1$ cyclic subgroups of order $ℓ$; it follows that, over $\Fbar_q$,
there are exactly $ℓ+1$ distinct (non-isomorphic) separable $ℓ$-isogenies 
from $E$ to other curves.
Generically, a connected component of the isogeny graph of
$ℓ$-isogenies over $\Fbar_q$ will be an infinite $(ℓ+1)$-regular
graph; a notable exception is the finite connected component of
\emph{supersingular} curves, used in SIDH and related protocols.

If one restricts to isogenies \emph{defined over $\F_q$}, the picture
becomes more complex.  By definition, an isogeny $ϕ:E→E'$ is
\emph{defined over} $\F_q$ if and only if the Frobenius endomorphism
$π$ stabilizes $\ker ϕ$. If $ϕ$ is cyclic, this is equivalent to
saying that $π$ acts like a scalar on the points of $\ker ϕ$.  Thus,
for any prime $ℓ≠p$, the number of outgoing $ℓ$-isogenies from $E$ 
defined over $\F_q$ can be
totally understood by looking at how $π$ acts on $E[ℓ]$. Since $E[ℓ]$
is a $ℤ/ℓℤ$-module of rank $2$, the action of $π$ is represented by a
$2×2$ matrix with entries in $ℤ/ℓℤ$ and characteristic polynomial
$X^2-tX+q\mod ℓ$. We then have four possibilities:
\begin{itemize}
\item[(0)] $π$ has no eigenvalues in $ℤ/ℓℤ$, i.e.\ $X^2-tX+q$ is
  irreducible modulo $ℓ$; then $E$ has no $ℓ$-isogenies.
\item[(1.1)] $π$ has one eigenvalue of (geometric) multiplicity one,
  i.e.\ it is conjugate to a non-diagonal matrix
  $\left(\begin{smallmatrix}λ&*\\0&λ\end{smallmatrix}\right)$; then
  there is one $ℓ$-isogeny from $E$.
\item[(1.2)] $π$ has one eigenvalue of multiplicity two, i.e.\ it acts
  like a scalar matrix
  $\left(\begin{smallmatrix}λ&0\\0&λ\end{smallmatrix}\right)$; then
  there are $ℓ+1$ isogenies of degree $ℓ$ from $E$.
\item[(2)] $π$ has two distinct eigenvalues, i.e.\ it is conjugate to a
  diagonal matrix
  $\left(\begin{smallmatrix}λ&0\\0&μ\end{smallmatrix}\right)$
	with $\lambda\neq\mu$; then
  there are two isogenies from $E$.
\end{itemize}

If we denote by $Δ_π=t^2-4q$ the discriminant of the characteristic
equation of $π$, we see that the cases~(1.x) are only possible if $ℓ$
divides $Δ_π$.  For ordinary curves $Δ_π≠0$, thus only a finite number
of primes $ℓ$ will fall in these cases, and they will be mostly
irrelevant to our cryptosystem. Following the literature on the SEA
point-counting algorithm~\cite{schoof95,todo}, if $ℓ$ falls into
case~(0) it will be called an \emph{Atkin prime}, if it falls into
case~(2) it will be called an \emph{Elkies prime}.

We will chiefly be interested in Elkies primes. Since all curves in
the same isogeny class over $\F_q$ have the same number of points,
they also have the same trace $t$ and discriminant $d_π$.
% todo: do we frown upon bold emphasis?
\textbf{It follows that, if $ℓ$ is an Elkies prime for a curve $E$,
  the connected component of $E$ in the graph of $ℓ$-isogenies is a
  finite $2$-regular graph, i.e.\ a cycle.} In the next subsection we
introduce a group action on this cycle, and determine its size.


\subsection{Complex multiplication}

In this subsection we exclusively focus on ordinary elliptic
curves. If $E$ is an ordinary curve with Frobenius map $π$, its
endomorphism ring $\End(E)$ is isomorphic to an
\emph{order}\footnote{Here, an \emph{order} is a subring which is a
  $ℤ$-module of rank $2$.} in the quadratic imaginary field
$ℚ(\sqrt{Δ_π})$ (see~\cite[III.9]{silverman:elliptic}).  A curve such
that it endomorphism ring is isomorphic to some order $\O$ is said to
have \emph{complex multiplication by $\O$}.  For a detailed treatment
of the theory of complex multiplication,
see~\cite{lang1987elliptic,silverman:advanced}.

The ring of integers $\O_K$ of $K=ℚ(\sqrt{Δ_π})$ is its
\emph{maximal order}, i.e.\ it contains any other order of $K$.  Hence
$ℤ[π]⊂\End(E)⊂\O_K$, and there is only a finite number of possible
choices for $\End(E)$: write $Δ_π=d^2Δ_K$, where $Δ_K$ is the
discriminant of $\O_K$, then the index $[\O_K:\End(E)]$ must divide
$d=[\O_K:ℤ[π]]$.

It turns out that isogenies allow us to \emph{navigate} the various
orders. If $ϕ:E→E'$ is an $\ell$-isogeny, then one of the following
holds~\cite[Prop.~21]{kohel}:
\begin{itemize}
\item $\End(E) = \End(E')$, then $ϕ$ is said to be
  \emph{horizontal};
\item $[\End(E):\End(E')] = ℓ$, then $ϕ$ is said to be
  \emph{descending};
\item $[\End(E'):\End(E)] = ℓ$, then $ϕ$ is said to be
  \emph{ascending}.
\end{itemize}
Notice that the last two cases can only happen if $ℓ$ divides
$d^2=Δ_π/Δ_K$, and thus correspond to cases (1.x) in the previous
subsection.
% todo: do we frown upon bold emphasis?
\textbf{If $ℓ$ does not divide $Δ_π$, then $ϕ$ is necessarily
  horizontal.}

We now present a group action on the set of all curves having complex
multiplication by a fixed order $\O$; the key exchange protocol of
Section~\ref{sec:keyex} will be built on this action. Let $\frak a$ be
% todo: shall we say "invertible" ideal?
an ideal in $\End(E)≃\O$, and define the
\emph{${\frak a}$-torsion} subgroup of $E$ as
\[
E[\frak a] = \set{P\in E(\Fbar_q) \suchthat \sigma(P) = 0\ 
\text{ for all }\sigma\in\frak a}.
\]
This subgroup is the kernel of an isogeny $\phi_{\frak a}$, defined up
to composition by an isomorphism, hence the codomain of
$\phi_{\frak a}$ is well-defined up to isomorphism.  We denote this
codomain by $\frak a\cdot E$, in other words
$\frak a\cdot E = E/E[\frak a]$.  The isogeny $\phi_{\frak a}$ is
always horizontal (i.e.\ $\End(\frak a \cdot E) = \End(E)$), and its
degree is the \emph{norm} of $\frak a$ as an ideal of $\End(E)$.

Write $\Ell_q(\O)$ for the set of isomorphism classes over $\Fbar_q$
of curves with complex multiplication by $\O$, and assume it is
non-empty. It turns out that the construction above may be extended
into a group action: namely, the group of fractional ideals of
$\End(\O)$ acts on $\Ell_q(\O)$. Furthermore, principal ideals act
trivially (since the corresponding isogenies are endomorphisms), 
so the action factors as an action of the \emph{ideal
  class group} $\Cl(\O)$ on $\Ell_q(\O)$.  The main theorem of complex
multiplication states that this action is \emph{simply transitive}. In
other terms, $\Ell_q(\O)$ is a \emph{principal homogeneous space}
under the group $\Cl(\O)$: if we fix a curve $E$ as base point,
then we have a bijection
\[
\begin{aligned}
\Cl(\O) &\longrightarrow \Ell_q(\O) \\
\text{Ideal class of }\frak a &\longmapsto \text{Isomorphism class of }\frak a\cdot E.
\end{aligned}
\]
The order of $\Cl(\O)$ is called the \emph{class number} of $\O$, and
denoted by $h(\O)$. An immediate consequence of the theorem is that
$\#\Ell_q(\O)=h(\O)$.

Now let $ℓ$ be an Elkies prime for $E$. So far, we have seen that the
connected component of $E$ in the $ℓ$-isogeny graph is a cycle of
horizontal isogenies. Complex multiplication tells us more. The
restriction of the Frobenius to $E[ℓ]$ has two eigenvalues $λ≠μ$, to
which we associate the prime ideals $\frak a=(π-λ,ℓ)$ and
$\hat{\frak a}=(π-μ,ℓ)$, both of norm $ℓ$. We see then that
$E[\frak a]$ is the eigenspace of $λ$, defining an isogeny
$ϕ_{\frak{a}}$ of degree $ℓ$. Furthermore
$\frak a\hat{\frak a} = \hat{\frak a}\frak a = (ℓ)$, implying that
$\frak a$ and $\hat{\frak a}$ are the inverse of one another in
$\Cl(\End(E))$, thus the isogeny $ϕ_{\hat{\frak a}}:\frak a·E→E$ of
kernel $(\frak a·E)[\hat{\frak a}]$ is the dual of $ϕ_{\frak a}$ (up
to isomorphism). Hence, 
% todo: more bold
\textbf{the eigenvalues $λ$ and $μ$ define two opposite
  \emph{directions} on the isogeny cycle, independently of the
  starting curve}, as shown in Figure~\ref{fig:cycle}.  Finally, the
size of the cycle is the order of $(π-λ,ℓ)$ in $\Cl(\End(E))$, thus
partitioning the set $\Ell_q(\End(E))$ into cycles of equal size.

\begin{figure}[t]
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \def\crater{7}
      \foreach \i in {1,...,\crater} {
        \begin{scope}[shorten >=0.1cm,->]
          \draw[blue!60!black] (360/\crater*\i : 1.95cm) -- (360/\crater*\i+360/\crater : 1.95cm);
          \draw[blue!60!white] (360/\crater*\i+360/\crater : 2.05cm) -- (360/\crater*\i : 2.05cm);
        \end{scope}
        \draw[blue!60!black] (360/\crater*\i+180/\crater:1.6cm) node {\small$λ$};
        \draw[blue!60!white] (360/\crater*\i+180/\crater:2cm) node {\small$μ$};
      }
      \foreach \i in {1,...,\crater} {
        \draw[fill] (360/\crater*\i:2cm) circle (2pt);
      }
    \end{tikzpicture}
    \caption{Isogeny cycle for an Elkies prime $ℓ$, with \emph{directions} associated to the Frobenius eigenvalues $λ$ and $μ$.}
    \label{fig:cycle}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \def\crater{12}
      \def\jumpa{-8}
      \def\jumpb{9}
      \def\diam{2cm}

      \foreach \i in {1,...,\crater} {
        \draw[blue] (360/\crater*\i : \diam) to[bend right] (360/\crater*\i+360/\crater : \diam);
        \draw[red] (360/\crater*\i : \diam) to[bend right] (360/\crater*\i+\jumpa*360/\crater : \diam);
        \draw[green] (360/\crater*\i : \diam) to[bend right=50] (360/\crater*\i+\jumpb*360/\crater : \diam);
      }
      \foreach \i in {1,...,\crater} {
        \pgfmathparse{int(mod(2^\i,13))}
        \let\exp\pgfmathresult
        \draw[fill] (360/\crater*\i: \diam) circle (2pt) +(360/\crater*\i: 0.4) node{$x^{\exp}$};
      }
    \end{tikzpicture}
    \caption{Schreier graph on a group $〈x〉$ of order $13$, acted
      upon by $(ℤ/13ℤ)^*$, generated by $S=\{2,3,5\}$ (respectively
      blue, red and green edges). Notice that $5$ has order $4$ modulo
      $13$, thus partitioning $〈x〉\setminus\{1\}$ into $3$ cycles of
      length $4$.}
    \label{fig:cayley}
  \end{minipage}
\end{figure}

\section{Key exchange from isogeny graphs}
\label{sec:keyex}

In this section, following Couveignes~\cite{cryptoeprint:2006:291} and
Rostovtsev and Stolbunov~\cite{rostovtsev+stolbunov06}, we describe a
key exchange protocol based on the action of a class group on an
isogeny graph.

Ideally, we would like to instantiate the key exchange protocol of
Algorithm~\ref{proto:hhs} with the principal homogeneous space
$\Ell_q(\O)$ for the class group $\Cl(\O)$, for some well chosen order
$\O$ in a quadratic imaginary field. However, given a generic element
of $\Cl(\O)$, the best algorithm~\cite{jao+soukharev10} to evaluate
its action on $\Ell_q(\O)$ has subexponential complexity in $q$,
making the protocol infeasible. The solution is to use a special
\emph{smooth} representation for the elements of $\Cl(\O)$.

In the next subsection, we present Stolbunov's key exchange
protocol~\cite{Stol}, in a more general framework using Cayley graphs.
Then, we present our improvement to Stolbunov's key exchange, taking
advantage of specially selected parameters to boost efficiency.


\subsection{Key exchange from Abelian Cayley graphs}

Let $G$ be a group, $S⊂G$ a subset, and $X$ a principal homogeneous
space for $G$. We define $\Graph(G, S, X)$ as the oriented graph which
vertices are the elements of $X$, and where an edge labelled by $s∈S$
links $x_1$ to $x_2$ if and only if $s\cdot x_1 = x_2$.  If $S$ is
symmetric (i.e.\ $S^{-1}=S$), we associate the same label to $s$ and
$s^{-1}$, and make the graph an undirected one. Such a graph is
isomorphic to the Cayley graph of $G$ generated by $S$, and is
sometimes called a \emph{Schreier graph}.  Figure~\ref{fig:cayley}
shows an example of Schreier graph where $G=(ℤ/13ℤ)^*$, $S=T∪T^{-1}$
where $T=\{2,3,5\}$, and $X$ is a cyclic group of order $13$ generated
by an element $x$, minus the identity element; the action of $G$ on
$X$ is given by exponentiation: $g·x=x^g$.

A \emph{walk} in a graph $\Graph(G,S,X)$ is a finite sequence
$(s_i)_{1≤i≤n}∈S^*$ of \emph{steps} in $S$. We extend the action of
$G$ on $X$ to an action of $S^*$ on $X$ by defining
\[(s_i)_i·x = \left(\prod_i s_i\right)·x.\] %
Note that if $G$ is Abelian the order of the steps in $(s_i)_i$ does
not matter.

If we have a Schreier graph where $G$ is finite and Abelian, and the
action $G$ on $X$ is efficiently computable, we can define a key
exchange protocol as in Algorithm~\ref{proto:cayley}.

\begin{algorithm}
  \caption{Generic key exchange from a Cayley graph}
  \label{proto:cayley}
  \Params{A \emph{base point} $x_0∈X$}
  \Alice{
    \Samples a random walk $(a_i)_i$ in $S^*$\; %$\Graph(G,S,X)$\;
    \Sends $x_a = (a_i)_i·x_0$ to Bob}
  \Bob{
    \Samples a random walk $(b_i)_i$ in $S^*$\; %$\Graph(G,S,X)$\;
    \Sends $x_b = (b_i)_i·x_0$ to Alice}
  \Key{$(a_i)_i·x_b = (b_i)_i·x_a$}
\end{algorithm}

If Alice and Bob ensure that the random walks induce a distribution on
$X$ close to uniform (in particular, the set $S$ must generate $G$),
then this protocol is essentially equivalent to
Algorithm~\ref{proto:hhs}. In particular, following the example of
Figure~\ref{fig:cayley}, if $X$ is a cyclic group $〈x〉$ of order
$p$, acted upon by $G=(ℤ/pℤ)^*$, then this protocol is equivalent to
the Diffie--Hellman protocol on $X$.

The specialization to isogeny graphs is now evident. We take:
\begin{itemize}
\item $X=\Ell_q(\O)$ as the vertex set, for some well-chosen $q$ and $\O$;
in particular we demand that $\O$ be the maximal order (see Section~\ref{sec:sec}).
\item $G=\Cl(\O)$ as the group acting on $X$;
\item $S$ a set of ideals of the form $(π-λ,ℓ)$, where $ℓ$ is an
  Elkies prime for the isogeny class $\Ell_q(\O)$,
  and $λ$ is an eigenvalue of Frobenius on $E[ℓ]$. 
  % (i.e.\ an integer in $ℤ/ℓℤ$).
\end{itemize}
The graph $\Graph(G,S,X)$ is thus an isogeny graph, composed of many
isogeny cycles superimposed on the same vertex set $\Ell_q(\O)$,
isomorphic to a Cayley graph of $\Cl(\O)$, connected if $S$ generates
$\Cl(\O)$, looking exactly like the one in Figure~\ref{fig:cayley}.

We will call a walk in this graph an \emph{isogeny walk}. The action of
an ideal $\frak s=(π-λ,ℓ)$ on an elliptic curve $E∈\Ell_q(\O)$ will be
evaluated by computing the unique isogeny $ϕ_{\frak s}:E→E'$ such that
$π(P)=λP$ for all $P∈\ker ϕ_{\frak s}$; algorithms for this operation are given
in the next subsection. The action of an isogeny walk $(\frak s_i)_i$
will be simply evaluated as the sequence of isogeny steps
$ϕ_{\frak s_i}$. Using this smooth representation of elements
in $\Cl(\O)$, one avoids computing the group $\Cl(\O)$,
the set $\Ell_q(\O)$, and performing arithmetic operations on ideal classes:
instead, only isogenies between elliptic curves are computed.


\subsection{Sampling and evaluating isogeny walks}

In order to boost the practical performances of our protocol,
we will compute \emph{skewed random walks} in the isogeny graph.
Indeed, the computational cost of an isogeny step may vary, and
we would like to compute costlier steps with smaller probability.

Given an ideal $\frak s = (\pi-\lambda, \ell)$ and an elliptic curve $E$,
we will compute $\phi_{\frak s}:E\to E'$ using one of two different algorithms:
\begin{itemize}
\item Algorithm~\algstyle{ElkiesStep}$(E, \ell, \lambda)$ that uses
	\emph{modular equations}, and works with any $\frak s$;
\item Algorithm~\algstyle{VéluStep}$(E, \ell,\lambda)$ that
	uses \emph{torsion points} on $E$, and can only be used when
	$\lambda$ satisfies certain properties.
\end{itemize}
Although the \emph{curve} $E$ is given as input to these algorithms,
we really work on isomorphism classes of curves.

Rostovtsev and Stolbunov only used an analogue of~\algstyle{ElkiesStep}. 
The introduction of Algorithm \algstyle{VéluStep}, 
inspired by the SIDH cryptosystem and related protocols,
speeds up the protocol by a considerable factor and
is the main contribution of our work. The set $S$ and the
sampling of random walks (i.e. secret keys) is designed
to take full advantage of algorithm~\algstyle{VéluStep},
when available. We give details about these two \algstyle{Step}
algorithms at the end of this subsection.

\paragraph{Construction of $S$.} The generating set will consist of

\begin{enumerate}
\item \label{case:elkstep} Ideals $(\pi - \lambda, \ell)$ and their inverses $(\pi - \mu, \ell)$
	for very small Elkies primes $\ell$, when \emph{neither} $\lambda$ nor $\mu$
	are eligible to algorithm~\algstyle{VéluStep}.
\item \label{case:velustep-sym} Ideals $(\pi - \lambda, \ell)$ and their inverses $(\pi - \mu, \ell)$
	for small Elkies primes $\ell$, when \emph{both} $\lambda$ and $\mu$
	are eligible to algorithm~\algstyle{VéluStep}.
\item \label{case:velustep-asym} Ideals $(\pi - \lambda, \ell)$, \emph{without their inverses},
	if $\ell$ is a small Elkies prime and \emph{only} eigenvalue $\lambda$
	is eligible to algorithm~\algstyle{VéluStep}.
\end{enumerate}

Therefore, $S$ can be encoded as three lists, each matching one of these three cases:

\begin{enumerate}
\item A list $S_E$ of tuples $(\ell, \lambda, \mu)$, the \emph{Elkies part} of $S$;
\item A list $S_{V, 2}$ of tuples $(\ell, \lambda, \mu)$, the \emph{symmetric Vélu part} of $S$;
\item A list $S_{V, 1}$ of tuples $(\ell, \lambda)$, the \emph{asymmetric Vélu part} of $S$.
\end{enumerate}

Looking back at Figure~\ref{fig:cycle}, in cases~\ref{case:elkstep} and~\ref{case:velustep-sym}
both directions $\lambda,\mu$ are used, while in case~\ref{case:velustep-asym} only $\lambda$ is
available.

\paragraph{Key generation.}

In Algorithm~\ref{proto:hhs}, (ephemeral) secret keys are random walks
in $S^*$. Since the class group $\Cl(\O)$ is commutative, such a walk is fully
determined by an \emph{exponent vector}, with one exponent for each ideal in $S$
up to inverse: for an ideal $\frak s\in S$, this exponent can be negative if
$\frak s^{-1}$ also appears in $S$, and must be nonnegative otherwise.

In order to minimize the cost of computing an isogeny walk, we use \emph{bounds}
on the number of steps for each ideal, as follows.
For each Elkies prime $\ell$ appearing in $S$, we define a bound $M_\ell$
on (the absolute value of) the exponent of ideals of norm $\ell$. As a rule,
$M_\ell$ will be much bigger in the Vélu case.

Algorithm~\algstyle{KeyGen} that generates secret keys can now
be described as follows: knowing the set $S$ and the bounds $M_\ell$,
\begin{itemize}
\item For each $(\ell, \lambda, \mu)\in S_E\cup S_{V, 2}$, pick $k_\ell\uni [-M_\ell, M_\ell]$;
\item For each $(\ell, \lambda)\in S_{V, 1}$, pick $k_\ell\uni [0,M_\ell]$;
\item Output the exponent vector $(k_\ell)_\ell$.
\end{itemize}

\paragraph{Key exchange.} Algorithm~\ref{alg:walk} describes how to use the
information contained in the secret key to compute an isogeny walk. Using
this primitive and Algorithm~\algstyle{KeyGen} outlined above,
Algorithm~\ref{alg:keyex} rephrases the generic key exchange~\ref{proto:cayley}
in our setting, making explicit all public parameters involved in the
protocol. This algorithm is presented in the classical Diffie--Hellman style,
although variants can also provide static-static key exchange (see Section~\ref{sec:sec}).

\begin{algorithm}
	\caption{\algstyle{Walk}: an isogeny walk}
	\label{alg:walk}
	\Input{
		\begin{itemize}
		\itemsep0em
		\item An ephemeral key $k = (k_\ell)_\ell$
		\item An initial curve $E_I$
		\item The set $S$ given as $S_E,\ S_{V,2},\ S_{V,1}$
		\end{itemize}
	}
	$E \gets E_I$\;
	\For{$(\ell, \lambda, \mu)\in S_E$}{
		\If{$k_\ell\geq 0$}{
			\lFor{$1\leq j \leq k_\ell$}{$E\gets \algstyle{ElkiesStep}(E, \ell, \lambda)$}
		}
		\Else{
			\lFor{$1\leq j \leq |k_\ell|$}{$E\gets \algstyle{ElkiesStep}(E, \ell, \mu)$}
		}
	}
	\For{$(\ell, \lambda, \mu)\in S_{V,2}$}{
		\If{$k_\ell\geq 0$}{
			\lFor{$1\leq j \leq k_\ell$}{$E\gets \algstyle{VéluStep}(E, \ell, \lambda)$}
		}
		\Else{
			\lFor{$1\leq j \leq |k_\ell|$}{$E\gets \algstyle{VéluStep}(E, \ell, \mu)$}
		}
	}
	\For{$(\ell,\lambda)\in S_{V,1}$}{
		\lFor{$1\leq j \leq k_\ell$}{$E\gets \algstyle{VéluStep}(E, \ell, \lambda)$}
	}
	\Return{E}
\end{algorithm}

\begin{algorithm}
  \caption{Key exchange from an isogeny graph}
  \label{alg:keyex}
  \Params{
		\begin{itemize}
		\itemsep0em
		\item A prime power $q$ 
		\item An ordinary elliptic curve $E_0/\F_q$ with Frobenius trace $t$, and maximal endomorphism ring
		\item The set $S$ given as $S_E,\ S_{V,2},\ S_{V,1}$
		\item Bounds $M_\ell$
		\end{itemize}
	}
  \Alice{
    \Samples $k_A = \algstyle{KeySample}(S, (M_\ell))$\;
    \Sends $E_A = \algstyle{Walk}(k_A, E_0, S)$ to Bob}
  \Bob{
    \Samples $k_B = \algstyle{KeySample}(S, (M_\ell))$\;
    \Sends $E_B = \algstyle{Walk}(k_B, E_0, S)$ to Alice}
  \Key{$\algstyle{Walk}(k_A, E_B, S) = \algstyle{Walk}(k_B, E_A, S)$}
\end{algorithm}



We now describe how isogeny steps are computed. Let $E\in\Ell_q(\O)$
and $\ell$ an Elkies prime for $E$, with Frobenius
eigenvalues $\lambda,\mu$. We would like to compute an $\ell$-isogeny
step from $E$ in direction $\lambda$, i.e. the isogeny $\phi_{\frak s}$
for $\frak s = (\pi-\lambda, \ell)$.

\paragraph{Algorithm~\algstyle{ElkiesStep}.} This algorithm uses
so-called modular equations to compute isogenies between elliptic
curves.  Specifically, we use the \emph{classical modular polynomial}
$\Phi_\ell(X, Y)$~\cite{todo:classicalmodpoly}.
This bivariate polynomial with integer coefficients has
the following property: a cyclic $\ell$-isogeny exists between two elliptic
curves $E$ and $E'$ if and only if $\Phi_\ell(j(E), j(E')) = 0$,
where $j$ denotes the $j$-invariant. Thus, the roots
of the polynomial equation $\Phi_\ell(j(E), X)=0$ give the two neighbors
of $E$ in the cycle of $\ell$-isogenies. The degree of this equation
is $\ell+1$.

Using this idea, when one picks a new prime $\ell$ and starts a sequence
of $\ell$-isogeny steps in direction $\lambda$, 
only one of the two neighbors is
correct. To determine which, choose one of them at random and
compute the \emph{kernel} $K$ of the corresponding $\ell$-isogeny. Several
algorithms have been designed for this purpose~\cite{todo:isogkernel}.
We then check whether the eigenvalue of $\pi$ on $K$ is indeed $\lambda$
by performing a scalar multiplication on the ``generic'' point of $K$.
This computation is only necessary for the \emph{first} $\ell$-isogeny
step, since no return on the isogeny cycle is allowed in Algorithm~\ref{alg:walk}.

In practice, we store modular polynomials $\Phi_\ell$
with coefficients already reduced in~$\F_q$. 
Several publicly available databases of modular polynomials
exist~\cite{todo:modulardatabases}. The size of the classical modular polynomial
$\Phi_\ell$ mentioned above grows quickly with $\ell$, so it is convenient
to use other types of modular equations when $\ell$ grows, such as the so-called
Atkin modular equations~\cite{todo:atkinmodpoly}. One then has to
modify the kernel computation accordingly~\cite{todo:isogkernelatkin}.

The costly step in Algorithm~\algstyle{ElkiesStep} is computing the roots
of the polynomial $\Phi_\ell(j(E), X)$. Using a Cantor--Zassenhaus-type
algorithm~\cite{todo:canzass}, this amounts to computing $X^q$ modulo
this polynomial. Using asymptotically fast methods for polynomial
arithmetic, the cost is $\softO(\ell\log q)$ field operations.

\paragraph{Algorithm \algstyle{VéluStep}.} This algorithm, very different
in spirit from Algorithm~\algstyle{ElkiesStep}, is given by the following
pattern:
\begin{itemize}
\item Find a nonzero $Q\in E[\frak s]$ (which is $\ker \phi_{\frak s}$),
\item Recover $\ker \phi_{\frak s}$ entirely by enumerating the multiples of $Q$,
\item Compute the image of $\phi_{\frak s}$ from its kernel using
Vélu's formulas~\cite{todo:velu}.
\end{itemize}
In order to find a nonzero element in $\ker\phi_{\frak s}$, we make the
following hypothesis: \emph{the multiplicative order of $\lambda$ in
$\Z/\ell\Z$ is $r$, and the multiplicative order of $\mu$ does not
divide $r$}. These multiplicative orders are easily computed
from $\ell$ and $\lambda$, but could as well be part of the public
parameters.

Then, $\ker\phi_{\frak s}$ is exactly the set of $\ell$-torsion
points on $E$ that are defined over $\F_{q^r}$. Let $C_{ext}$ be the
order of $E(\F_{q^r})$, which can be quickly computed from the
Frobenius trace $t$~\cite{todo:hasseext}.
We proceed as follows:
\begin{itemize}
\item Pick a random point $P\in E(\F_{q^r})$,
\item Compute $Q = \left[\frac{C_{ext}}{\ell}\right]P$,
\item If $Q = 0$ restart, else return $Q$.
\end{itemize}
The probability that more than one scalar multiplication will be computed
is only $\frac{1}{\ell}$.

When $\ell$ is not too large, the cost is dominated by that of the scalar
multiplication. Using asymptotically fast arithmetic operations,
the overall cost is $\softO(r^2\log q)$ field operations, as $C_{ext}$
has the same order of magnitude as $q^r$. Since the scalar
multiplication dominates, Algorithm~\algstyle{VéluStep} can be improved
by using elliptic curve models with more efficient arithmetic~\cite{todo:curvearith}.

Note that when $r = 1$
(i.e. $\lambda = 1$), we save a factor $\ell$ over Algorithm~\algstyle{ElkiesStep},
in addition with much better constant factors. As a general rule,
algorithm \algstyle{VéluStep} is more efficient when $r$ is small, while
for generic values of $r$ (typically $O(\ell))$ Algorithm~\algstyle{ElkiesStep}
should be preferred.

Even if the multiplicative order of $\lambda$ divides that of $\mu$,
we can still try to use Algorithm~\algstyle{VéluStep} in both directions.
The trick is to use the \emph{quadratic twist} of $E$. While this does not
change the isomorphism class of the curve, the Frobenius eigenvalues
become $-\lambda$ and $-\mu$. For example, if
$p \equiv -1\pmod{\ell}$ and $\lambda = 1$, then $\mu=-1$ and 
Algorithm~\algstyle{VéluStep} can be used in both directions with $r=1$.

\section{Public parameter selection}
\label{sec:initcurve}

It is now evident that the choice of public parameters, especially
the initial curve $E_0$, has heavy impact on the execution time:
smaller Elkies primes,
and smaller multiplicative orders of the Frobenius eigenvalues, will
lead to better practical performances. Since all of this information
is contained in the value of $\# E(\F_q)$, we now face the problem
of constructing ordinary elliptic curves with prescribed
order, or more precisely with prescribed order \emph{modulo small
primes}. Unfortunately, and in contrast with the case of
supersingular curves, no polynomial-time method to achieve this 
is known in general; the CM method~\cite{todo:cmmethod}, which solves this problem
when the corresponding class groups are small, is useless in our
setting as we will see in Section~\ref{sec:sec}.

In this section, we describe how to use the Schoof--Elkies--Atkin (SEA) point counting
algorithm with early abort, combined with the use of certain modular curves,
to construct curves whose cardinality satisfies some constraints
modulo small prime.
This is faster than choosing curves at random and computing their cardinalities
completely until a convenient one is found, but still does not allow us
to use the full power of Algorithm~\algstyle{VéluStep}.

\paragraph{Early-abort SEA.}
The SEA algorithm~\cite{schoof95,todo} is a polynomial-time algorithm for
point counting on elliptic curves over a finite field. In order to compute
$C = \# E(\F_p)$, it computes the value of $C$ modulo a series
of small primes $\ell$: it is a \emph{multimodular algorithm}.
Cryptographers are usually interested in generating elliptic curves of
prime or nearly prime order. In this case, one uses an \emph{early-abort}
mechanism: when $C \equiv 0\pmod{\ell}$ for some $\ell$, the algorithm is aborted
and a new curve is chosen.

Here, the situation is the opposite: we \emph{want} elliptic curves
whose cardinality has lots of small factors. To fix ideas, let us choose
\[
p = 7 \left(\prod_{2\leq\ell\leq 380,\ \ell \text{ prime}} \ell\right) - 1
\]
which is a 512-bit prime. Then, Algorithm~\algstyle{VéluStep} can be used
for $\ell$-isogenies with $r=1$ in both directions if and only if
$C_0 = \# E_0(\F_p)$ satisfies $C_0 \equiv0\pmod{\ell}$.

We now proceed as follows:
\begin{itemize}
\item Choose a smoothness bound $B$ (we used $B = 13$).
\item Pick elliptic curves $E$ at random in $\F_p$, and use the SEA algorithm,
aborting when any $\ell\leq B$ 
with $\#E(\F_p) \not\equiv 0\pmod{\ell}$ is found.
\item For each curve which passed the tests above, complete the SEA
algorithm and estimate the key exchange running time using this
curve as a public parameter (see Section~\ref{sec:exp}).
\end{itemize}
The ``fastest'' curves now give promising candidates for $\#E_0(\F_p)$.

Considering the efficiency of this procedure, it is important to remark
that very few curves will pass the early-abort tests. The bound $B$ is
chosen to balance the overall cost of the first few tests with that of
the complete SEA algorithm for the curves which pass them. Therefore,
its value is somewhat implementation-dependent. In practice, one also
incorporates the test of existence of a Montgomery model for the
elliptic curve as in~\cite{todo:refMontgomery}.

\paragraph{Finding the maximal order.}
Once such a curve $E_1$ has been computed, it is important to find a curve
$E_0$ having the same order, but whose endomorphism ring is maximal, and
to ensure that its discriminant is a large integer. Therefore, we attempt to
factor the discriminant $\Delta_\pi$ of $\Z[\pi]$: if it is squarefree,
then $E_1$ already has maximal endomorphism ring, and in general the square
factors of $\Delta_\pi$ indicate which isogeny volcanoes have to be climbed up
in order to find $E_0$.

\begin{remark}
Factoring random 512-bit integers is not hard, and quadratic discriminants
tend to be slightly smoother than random integers.
It took less then one hour of GMP-ECM on 10 cores to factor the 512 bits discriminant
given at the end of this section. %todo: which hardware ?
If this fails,
a conservative strategy would be to discard this discriminant; alternatively
one could argue that leaving an unsmooth enough unfactored part is not a
security issue, since such large-degree isogenies would be untractable to
compute anyway (see section~\ref{sec:sec}).
\end{remark}

\paragraph{Using the modular curve $X_1(N)$.}
Since we are looking for curves with smooth cardinalities, another
improvement to this procedure is available: instead of using elliptic
curves uniformly chosen at random, we pick random candidates using
an equation for the modular curve $X_1(N)$~\cite{sutherland2012constructing}.
This way, one guarantees the existence of a rational $N$-torsion point
on the elliptic curve without any further computation. In our
implementation, we used $N = 17$. This idea is used, for example,
in the procedure of selecting elliptic curves in the Elliptic Curve Method
for factoring~\cite{todo:refECM}.

\paragraph{Results.}
We implemented this research using the Sage computer algebra system.
After 17,000 hours of CPU time, we found the elliptic curve under
Montgomery form %todo: which hardware ?
$
	E : y^2 = x^3 + A x^2 + x
$
over $\F_p$ where the prime $p$ is given above, and
\[
\begin{aligned}
A =\ 
& 1086133850464928038385995014077294700770364640837283 \\
& 1934324660566888732797778932142488253565145603672591 \\
& 944602210571423767689240032829444439469242521864171\,.
\end{aligned}
\]
The trace of Frobenius $t$ of $E$ is
\[
\begin{aligned}
-&147189550172528104900422131912266898599 \\
&387555512924231762107728432541952979290\,.
\end{aligned}
\]

This curve, or its twist, has a rational $\ell$-torsion point 
for each $\ell$ in
\[
  \{3, 5, 7, 11, 13, 17, 103, 523, 821, 947, 1723\}
  \,,
\]
and each of these primes $\ell$ is of Type (2)
in the sense of Subsection~\ref{sec:isogeny-graphs}.
Furthermore, $\End(E)$ is the maximal order, and its discriminant is
a 511-bit integer that has the following prime factorization:
\[
\begin{aligned}
& -2^3 \cdot 20507 \cdot 67429 \cdot 11718238170290677 \cdot 12248034502305872059 \\
& \cdot 60884358188204745129468762751254728712569\\
& \cdot 68495197685926430905162211241300486171895491480444062860794276603493\,.
\end{aligned}
\]

Other proposals for public parameters are given in~\cite{todo:memoire}.
In the sequel, we will argue that using this curve brings a 128-bit security level
in the classical as well as quantum setting, and we give running times of the whole
scheme in our implementation.

\section{Security}
\label{sec:sec}

We now address the security of the CRS primitive, and derived
protocols. Intuitively, these systems rely on two assumptions:
\begin{enumerate}
\item Given two elliptic curves $E,E'$ in $\Ell_q(\O)$, it is hard to
  find a (smooth degree) isogeny $ϕ:E→E'$;
\item The distribution on $\Ell_q(\O)$ induced by the random walks
  sampled in Algorithm~\ref{alg:keyex} is computationally
  undistinguishable from the uniform distribution.
\end{enumerate}

We start by reviewing the known attacks for the first problem, both in
the classical and the quantum setting. Then, we formalize security
assumptions and give security proofs against passive adversaries.
Finally, we discuss key validation and protection against active
adversaries.

\subsection{Attacks}
\label{sec:attacks}

\paragraph{Classical attacks.}
We start by addressing the following, more general, problem:

\begin{prob}
\label{prob:isog}
  Given two ordinary elliptic curves $E,E'$ defined over a finite
  field $\F_q$, such that $\#E(\F_q)=\#E'(\F_q)$, find an isogeny walk
  $(ϕ_i)_{1≤i≤n}$ such that $ϕ_n∘\cdots∘ϕ_1(E)=E'$.
\end{prob}

This problem was studied for some time before the emergence of
isogeny-based cryptography~\cite{Gal,GHS,galbraith+stolbunov11},
because of its applications to elliptic curve
cryptography~\cite{GHS,teske06,jao+miller+venkatesan09}.  The
algorithm with the best asymptotic complexity is due to Galbraith,
Hess and Smart~\cite{GHS}. It consists of three stages:
\begin{description}
\item[Stage 0.] Use walks of \emph{ascending} isogenies to reduce to the case where
  $\End(E)\cong\End(E')$ is the maximal order.
\item[Stage 1.] Start two random walks of horizontal isogenies 
  from $E$ and $E'$; detect the
  moment when they collide using a Pollard-rho type of algorithm.
\item[Stage 2.] Reduce the size of the obtained walk using
  index-calculus techniques.
\end{description}

To understand Stage~0, recall that all isogenous elliptic curves have
the same order, and thus the same trace $t$ of the Frobenius
endomorphism $π$. Define the Frobenius discriminant $Δ_π=t^2-4q$, then
$\End(E)$ is contained in the ring of integers $\O_K$ of
$K=ℚ(\sqrt{Δ_π})$. Write $Δ_π=d^2Δ_K$, where $Δ_K$ is the
discriminant\footnote{$Δ_K$ is also called a \emph{fundamental
    discriminant}; it is in $\{0,1\}\bmod 4$, and either $Δ_K$ or
  $Δ_K/4$ is squarefree.} of $\O_K$, then for any $ℓ\mid d$ the
$ℓ$-isogeny graph of $E$ contains \emph{ascending} and
\emph{descending} isogenies and is sometimes referred to as a
\emph{volcano}~\cite{fouquet+morain02} (see Figure~\ref{fig:volcano}).
Ascending isogenies go from curves with smaller endomorphism rings to
curves with larger ones, and take us to a curve with $\End(E)≃\O_K$ in
$O(\log d)$ steps; they can be computed efficiently using the
algorithms
of~\cite{kohel,fouquet+morain02,ionica+joux13,defeo2016explicit},
thus, Stage~0 can be accomplished\footnote{This statement is assuming
  that all prime factors of $d$ are in $O(\log q)$, which is typically
  the case for isogeny-based protocols: no counter-example
	has ever been constructed.}  in time polynomial in
$\log q$.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \def\crater{7}
    \foreach \i in {1,...,\crater} {
      \draw[fill] (360/\crater*\i:1cm) circle (5pt);
      \draw (360/\crater*\i : 1cm) -- (360/\crater*\i+360/\crater : 1cm);
      \foreach \j in {-1,1} {
        \draw[fill] (360/\crater*\i : 1cm) -- (360/\crater*\i + \j*360/\crater/4 : 2cm) circle (3pt);
        \foreach \k in {-1,0,1} {
          \draw[fill] (360/\crater*\i + \j*360/\crater/4 : 2cm) --
          (360/\crater*\i + + \j*360/\crater/4 + \k*360/\crater/6 : 2.5cm) circle (1pt);
        }
      }
    }
  \end{tikzpicture}
  \caption{$3$-isogeny graph (\emph{volcano}) containing the curve
    with $j(E)=607$ over $\F_{6007}$. A larger vertex denotes a larger
    endomorphism ring.}
  \label{fig:volcano}
\end{figure}

The class $\Ell_q(\O_K)$ is the smallest among all classes
$\Ell_q(\O)$ for $\O⊂\O_K$, so it is always interesting to
reduce to it. This justifies using curves with maximal endomorphism
ring in the definition of the protocol in
Section~\ref{sec:keyex}. We remark that when $Δ_π$ is square-free, $ℤ[π]$
is the maximal order, and hence this condition is automatically satisfied.

The collision search in Stage~1 relies on the birthday paradox, thus
it has a complexity of $O(\sqrt{h})$, where $h=\#\Ell_q(\O_K)$ is the
class number of $\O_K$.  It is known that, on average,
$h(\O_K)≈0.461\cdots\sqrt{|Δ_K|}$ (see~\cite[5.10]{Cohen1993}), and,
assuming the extended Riemann hypothesis, we even have a lower bound
(see~\cite{littlewood1928class})
\[h(\O_K) ≥ 0.147\cdots\frac{(1+o(1))\sqrt{|Δ_K|}}{\log\log|Δ|}.\]
Given that $Δ_K\sim q$, we expect Stage~1 to take time $O(q^{1/4})$,
thus justifying the choice of a $q$ four times as large as the
security parameter.  Unfortunately, class numbers are notoriously
difficult to compute, the current record being the computation of
$h(\O_K)$ for a discriminant of 300
bits~\cite{10.1007/978-3-642-14081-5_15}. Computing the class
number for a discriminant of $\sim 500$ bits seems to be expensive,
albeit feasible, thus we will only rely on these heuristic arguments
to justify the security of our proposed parameters.
% todo: check this is really the latest record

Finally, Stage~2,
which outputs an isogeny walk of size polynomial in $\log q$,
has a complexity bounded by that of Stage~1.
It therefore has no impact on our security estimates.

\begin{remark}
  The Cohen--Lenstra heuristic~\cite{10.1007/BFb0099440} predicts that
  the odd part of $\Cl(\O_K)$ is cyclic with overwhelming
  probability; and more heuristics~\cite{10.1007/3-540-44448-3_18}
  indicate that $h(\O_K)$ is likely to have a large prime factor.
  However, since there is no known way in which the group structure of
  $\Cl(\O_K)$ can affect the security of our protocol, we can 
  disregard this matter. No link between the group structure
	of $E(\F_q)$ itself and the security is known, either.
\end{remark}

\paragraph{Quantum attacks.}
On a quantum computer, an attack with better asymptotic complexity is
given in~\cite{childs2014constructing}. It consists of two algorithms:
\begin{enumerate}
\item A (classical) algorithm that takes as input an elliptic curve
  $E∈\Ell_q(\O)$ and an ideal $\frak a∈\Cl(\O)$, and outputs the curve
  $\frak a·E$;
\item A generic quantum algorithm for the dihedral hidden subgroup
  problem (dHSP), based upon previous work of Kuperberg~\cite{Kup} and
  Regev~\cite{regev04}.
\end{enumerate}

The ideal evaluation algorithm has sub-exponential complexity
$L_q(\frac{1}{2},\frac{\sqrt{3}}{2})$.  The dHSP algorithm uses the
ideal evaluation algorithm as a (quantum) black box, the number of
queries depending on the variant:
\begin{itemize}
\item Kuperberg's algorithm uses $O(2^{\sqrt{\log q}})$ queries, and a
  storage of $O(2^{\sqrt{\log q}})$ qubits;
\item Regev's algorithm has worse query complexity, using
  $L_q(\frac{1}{2},1)$ calls to the black box, but only requires a
  storage of $\poly(\log q)$ qubits.
\end{itemize}

Based on these estimates, we expect the bit size of $q$ to grow at
worst like the square of the security parameter. However, given that
the constants implied in the complexities are not made explicit, it is
hard to estimate the impact of this attack at concrete security levels
such as those required by NIST~\cite{NIST2016}. Nevertheless, we
remark that the weaker version of Kuperberg's algorithm described
in~\cite[§2.1]{regev04}, requires about $2^{\sqrt{8\log q}}$ queries
to the black box; this number can be taken as a very conservative
lower bound, given that the described algorithm is specific to
$h(O_K)=2^n$, and also because Regev's algorithm, with its polynomial
storage requirement, is a much more realistic candidate to run on a
real world quantum computer. By taking into account the fact that each
black box query runs a quantum circuit of subexponential size itself,
we estimate that the lower bound on the number of quantum gates is at
least the square of the lower bound on the number of quantum
queries. Based on these observations, we propose in
Table~\ref{tab:sizes} parameter sizes matching three of the NIST
categories~\cite{NIST2016}.
According to this table, the public parameters we proposed
in Section~\ref{sec:initcurve} fit in NIST category 2.

\begin{table}
  \renewcommand{\arraystretch}{1.4}
  \centering
  \begin{tabular}{c | c | c | c | c | c}
    $\log Δ_K$ & $\log h(\O_K)$
    & \parbox{10ex}{\centering classical security}
    & \parbox{10ex}{\centering quantum queries}
    & \parbox{10ex}{\centering quantum security}
    & \parbox{10ex}{\centering NIST category}\\
    \hline
    $512$  & $256$ & $2^{128}$ & $> 2^{64}$ & $2^{128}$ & 2\\
    $768$  & $384$ & $2^{192}$ & $> 2^{78}$ & $> 2^{156}$ & 3\\
    $1024$ & $512$ & $2^{256}$ & $> 2^{90}$ & $> 2^{180}$ & 5
  \end{tabular}
  \caption{Suggested parameter sizes at different security levels.}
  \label{tab:sizes}
\end{table}

\subsection{Security proofs}
\label{sec:proofs}

We now formalize the assumptions needed to prove the security of the
key exchange protocol, and other derived protocols such as PKEs and
KEMs, in various models. Given the similarity with the classical
Diffie--Hellman protocol on a cyclic group, our assumptions will be
mostly modeled after those used in that context. Here we are
essentially following the lead of
Couveignes~\cite{cryptoeprint:2006:291} and
Stolbunov~\cite{Stol,Stolbunov2012}, however we take their analyses a
step further by explicitly modeling the hardness of distinguishing
random walks on Cayley graphs from the uniform distribution: this
yields stronger proofs and a better separation of security concerns.

We will write $x\rand{σ} X$ for an element taken from a set $X$
according to a probability distribution $σ$. If $X$ is finite,
then we write $x\uni X$ for an element taken according to the uniform
distribution.

For the rest of this section $q$ is a prime power, $\O$ is an order in
a quadratic imaginary field with discriminant $Δ\sim q$, $\Cl(\O)$ is
the class group of $\O$, $\Ell_q(\O)$ is the (non-empty) set of
elliptic curves with complex multiplication by $\O$, and $E_0$ is a
fixed curve in $\Ell_q(\O)$. Finally, $S$ is a set of ideals of $\O$
with norm polynomial in $\log q$, and $σ$ is a probability
distribution on $S^*$, used to sample secrets in the key exchange
protocol.

The assumption needed to prove security of the protocols is analogous
to the classical DDH assumption.

\begin{definition}[Isogeny Walk Decisional Diffie--Hellman (IW-DDH)]
  Given curves $E_a,E_b,E_{ab}∈\Ell_q(\O)$ sampled with probability
  $\frac{1}{2}$ from one of the following two distributions
  \begin{align*}
    \mathcal{R}_{q,Δ} &= \left\{\bigl((\frak a_i)_i·E_0,(\frak b_i)_i·E_0,E'\bigr) \suchthat
                        (\frak a_i)_i,(\frak b_i)_i\rand{σ}S^*,\;
                        E'\uni\Ell_q(\O)\right\},\\
    \mathcal{W}_{q,Δ,σ} &= \left\{\bigl((\frak a_i)_i·E_0,(\frak b_i)_i·E_0,(\frak a_i)·(\frak b_i)·E_0\bigr) \suchthat
                          (\frak a_i)_i,(\frak b_i)_i\rand{σ}S^*\right\},
  \end{align*}
  decide from which of the two they were sampled.
\end{definition}

We split this assumption into two finer grained assumptions. The first
states that it is computationally hard to distinguish between
commutative squares sampled uniformly at random and commutative
squares sampled from the distribution $σ$.

\begin{definition}[Isogeny Walk Distinguishing (IWD)]
  Given curves $E_a,E_b,E_{ab}∈\Ell_q(\O)$ sampled with probability
  $\frac{1}{2}$ from one of the following two distributions
  \begin{align*}
    \mathcal{G}_{q,Δ} &= \left\{(\frak a·E_0,\frak b·E_0,\frak{ab}·E_0) \suchthat
                        \frak a,\frak b\uni\Cl(\O)\right\},\\
    \mathcal{W}_{q,Δ,σ} &= \left\{\bigl((\frak a_i)_i·E_0,(\frak b_i)_i·E_0,(\frak a_i)·(\frak b_i)·E_0\bigr) \suchthat
                          (\frak a_i)_i,(\frak b_i)_i\rand{σ}S^*\right\},
  \end{align*}
  decide from which of the two they were sampled.
\end{definition}

The second assumption is an analogue of DDH in the context of group
actions. It also appears in~\cite{cryptoeprint:2006:291} under the
name \emph{vectorization}, and in~\cite{Stol,Stolbunov2012} under the
name DDHAP.
 
\begin{definition}[Class Group Action Decisional Diffie--Hellman (CGA-DDH)]
  Given curves $E_a,E_b,E_{ab}∈\Ell_q(\O)$ sampled with probability
  $\frac{1}{2}$ from one of the following two distributions
  \begin{align*}
    \mathcal{U}_{q,Δ} &= \left\{(E_a,E_b,E_{ab}) \suchthat E_a,E_b,E_{ab}\uni\Ell_q(\O)\right\},\\
    \mathcal{G}_{q,Δ} &= \left\{(\frak a·E_0,\frak b·E_0,\frak{ab}·E_0) \suchthat
                        \frak a,\frak b\uni\Cl(\O)\right\},
  \end{align*}
  decide from which of the two they were sampled.
\end{definition}

We want to prove the security of protocols based on the primitive of
Section~\ref{sec:keyex} under the CGA-DDH and IWD assumptions
combined. To do this we give a lemma showing that CGA-DDH and IWD
together imply IW-DDH. The technique is straightforward: we use an
IW-DDH oracle to solve both the CGA-DDH and IWD problems, showing that
at least one of the two must be solvable with non-negligible
advantage. The only technical difficulty lies in the fact that we need
an efficient way to simulate the uniform distribution on $\Ell_q(\O)$;
for this, we use another Cayley graph on $\Ell_q(\O)$, potentially
with a larger edge set, that is proven
in~\cite{jao+miller+venkatesan09} to be an expander.

We let $\Adv[A]{IW-DDH}$ be the \emph{advantage} of an adversary $A$
against IW-DDH, defined as the probability that $A$ answers correctly,
minus $\frac{1}{2}$:
\[2\Adv[A]{IW-DDH} = \Proba\bigl[A(\mathcal{R}_{q,Δ}) = 1\bigr] -
  \Proba\bigl[A(\mathcal{W}_{q,Δ,σ}) = 1\bigr].\] %
We define similarly $\Adv[A]{CGA-DDH}$ and $\Adv[A]{IWD}$. By switching
answers if needed, we can assume all advantages are positive. We
denote by $\Adv{xxx}(t)$ the maximum of $\Adv[A]{xxx}$ over all
adversaries using at most $t$ resources (e.g.\ running time, queries,
etc.).

\begin{lemma}
\label{lem:adv}
  Assuming GRH, for $q$ large enough and for any bound $t$ on running
  time, and for any $\epsilon>0$,
  \[\Adv{IW-DDH}(t) ≤ 2\Adv{IWD}(t+\poly(\log q, \log\epsilon)) + \Adv{CGA-DDH}(t) + \epsilon.\]
\end{lemma}
\begin{proof}[Proof (Sketch)]
  We start with an adversary $A$ for IW-DDH, and we construct two simulators
  $S$ and $T$ for CGA-DDH and IWD respectively.

  The simulator $S$ simply passes its inputs to $A$ and returns
  whatever response $A$ gives.

  The simulator $T$ receives a triplet $(E_a,E_b,E_{ab})$ taken from
  one of $\mathcal{G}_{q,Δ}$ or $\mathcal{W}_{q,Δ,σ}$. It flips a coin
  to decide which of the two following actions it will do:
  \begin{itemize}
  \item It forwards $(E_a,E_b,E_{ab})$ to $A$, it returns the same bit
    as given by $A$;
  \item It generates a random curve $E_c∈\Ell_q(\O)$, it forwards
    $(E_a,E_b,E_c)$ to $A$, it returns the opposite bit to the one
    given by $A$.
  \end{itemize}
  
  The curve $E_c$ must be taken from a distribution close to uniform
  for the simulator to work. The only way at our disposal to sample
  $E_c$ uniformly would be to sample a uniform $\frak c∈\O$, and take
  $E_c=\frak c·E_0$, but this would be too costly. Instead we
  use~\cite[Theorem~1.5]{jao+miller+venkatesan09},
	combined with standard results about random walks in
	expander graphs, to sample $E_c$ so
  that any curve in $\Ell_q(\O)$ is taken with probability between
  % todo: Jean, you mentioned that you could get closer to the uniform
  % distribution by lengthening the walks?
  $(1-\epsilon)/h(\O)$ and $(1+\epsilon)/h(\O)$,
	using only $\poly(\log q, \log\epsilon)$ operations.
	We can consider this sampling as follows:
	with probability $1-\epsilon$, sample $E_c$ \emph{uniformly},
	and with probability $\epsilon$ sample it from
	an unknown probability distribution.

  Now, if $T$ forwarded $(E_a,E_b,E_{ab})$ untouched, it is immediate
  to see that
  \[2\Adv[T]{IWD} = \Adv[A]{IW-DDH} - \Adv[S]{CGA-DDH},\] %
  while if $T$ forwarded $(E_a,E_b,E_c)$, then we get
  \[2\Adv[T]{IWD} \geq \Adv[A]{IW-DDH} - (1-\epsilon)\Adv[S]{CGA-DDH} - \epsilon.\] %
  Averaging over the two outcomes gives in particular
  \[2\Adv[T]{IWD} \geq \Adv[A]{IW-DDH} - \Adv[S]{CGA-DDH} - \epsilon,\] %
  concluding the proof.
\end{proof}

Finally, we give an assumption akin to the classical CDH assumption
for groups. Using the same techniques as above, we can prove the
security of the relevant protocols based only on CGA-CDH and IWD,
\emph{without GRH}.

\begin{definition}[Class Group Action Computational Diffie Hellman (CGA-CDH)]
  Given curves $E_a=\frak a·E_0$ and $E_b=\frak b·E_0$, with
  $\frak a,\frak b\uni\Cl(\O)$, compute the curve
  $E_{ab}=\frak{ab}·E_0$.
\end{definition}

We can now prove the security of our schemes. Stolbunov already proved
the security of Algorithm~\ref{proto:hhs} under the equivalent of
CGA-DDH~\cite{Stol}. By repeating the same steps, we can prove the
following theorem.

\begin{theorem}
  If the CGA-DDH and IWD assumptions hold, assuming GRH, the
  key-agreement protocol in Algorithm~\ref{alg:keyex} is session-key
  secure in the authenticated-links adversarial model of Canetti and
  Krawczyk~\cite{canetti}.
\end{theorem}

Similarly, we can prove the IND-CPA security of the hashed El Gamal
protocol derived from Algorithm~\ref{alg:keyex} by replicating the
classical techniques of, for
instance,~\cite[20.4.11]{galbraith2012mathematics}.

\begin{theorem}
  Assuming CGA-CDH and IWD, the hashed El Gamal protocol derived from
  Algorithm~\ref{alg:keyex} is IND-CPA secure in the random oracle
  model.
\end{theorem}


\paragraph{A heuristic discussion of the IWD assumption.}

From its very definition, the IWD assumption depends on
the probability distribution $\sigma$ we use to sample
random walks in the isogeny graph. In this paragraph,
we provide heuristic arguments indicating that IWD is hard
using Algorithm~\ref{alg:walk}, provided the following
two statements are true:
\begin{itemize}
\item $S$ is \emph{not too small}, i.e. the number of
isogeny degrees used is $\Omega(\log q)$;
\item The keyspace size is at least $\sqrt{|\Delta_K|}$.
\end{itemize}

At present, proving rapid mixing of random walks with such
parameters seems out of reach even under number-theoretic
hypotheses such as GRH. The best results available,
like~\cite[Theorem~1.5]{jao+miller+venkatesan09}
that was used in the proof of Lemma~\ref{lem:adv},
typically require isogeny degrees $\Omega((\log q)^B)$
for some $B>2$, and fully random walks that are not,
for example, skewed towards smaller-degree isogenies.

However, numerical evidence widely suggests that
such results are too weak. In~\cite[7.2]{jao+miller+venkatesan09},
it is asked whether an analogue of the previous theorem would
be true with the sole constraint $B>1$. In~\cite[Section~3]{GHS},
it is mentioned that many fewer split primes are needed to walk
in the isogeny graph than theoretically expected.
We believe that these experiments can bring some evidence
in favor of relying on the IWD assumptions with more aggressive
parameters than those provided by GRH.

Regarding the skewing of random walks,
practical evidence also suggests that the rapid mixing
properties are not lost: in~\cite{galbraith+stolbunov11},
such walks are used to accelerate the algorithm
solving Problem~\ref{prob:isog}.

\subsection{Key validation and active security}

Modern practice in cryptography mandates the use of stronger security
notions than IND-CPA.  From the DLP assumption, it is easy to
construct protocols with strong security against active adversaries.
For example, it is well known that the hashed El Gamal KEM achieves
IND-CCA security in the random oracle model under various
assumptions~\cite[§7]{10.1007/3-540-45353-9_12,cryptoeprint:1999:007,doi:10.1137/S0097539702403773}.
All these constructions crucially rely on \emph{key validation}, i.e.\
Alice must verify that the public data sent by Bob defines valid
protocol data (e.g., valid elements of a cyclic group), or abort if
this is not the case.

Failure to perform validation may result in catastrophic attacks, such
as small subgroup~\cite{10.1007/BFb0052240}, invalid
point~\cite{10.1007/3-540-44598-6_8}, and invalid curve
attacks~\cite{Ciet2005}.  In our context, key validation amounts to
verify that the curve sent by Bob really is an element of
$\Ell_q(\O_K)$. Failure to do so exposes Alice to an \emph{invalid
  graph attack} where Bob forces Alice onto an isogeny class with much
smaller discriminant, or different Elkies primes, and learns something
on Alice's secret.

Fortunately, key validation is relatively easy for protocols based on
the CRS primitive. All we need to check is that the received curve has
the right order, and has maximal endomorphism ring. Notice that,
because these algorithms only operate on public data, they do not need
to be constant-time.

\paragraph{Verifying the order.} Since we already know the trace $t$
of the Frobenius endomorphism of $E$, we only need to check that the
order is equal to $q+1-t$. Assuming that $E$ is cyclic, or contains a
cyclic group of order larger than $4\sqrt{q}$, a very efficient
randomized algorithm consists in taking a random point $P$ and
verifying that it has the expected order.  This task is easy if the
factorization of $q+1-t$ is known.

Concretely, the curve given in Section~\ref{sec:initcurve} has order
\[N = 2^2 · 3^2 · 5 · 7 · 11 · 13^2 · 17 · 103 · 523 · 821 ·
  1174286389 · m,\] %
where $m$ is a $432$ bits prime, and its group structure is
$ℤ/2ℤ×ℤ/\frac{N}{2}ℤ$. To check that a curve is in the same isogeny
class, we repeatedly take random points until we find one with order
$N/2$.

\paragraph{Verifying the \emph{level}.} The previous verification
proves that endomorphism ring of $E$ is contained between $ℤ[π]$ and
$\O_K$. We have already seen that there is only a finite number of
possible rings, and their indices must divide $d^2=Δ_π/Δ_K$. Ascending
and descending isogenies connect curves with different endomorphism
rings, thus we are left with the problem of verifying that $E$ is on
the crater of any $ℓ$-volcano for $ℓ\mid d$.

Assuming that no large prime divides $d$, this check can be
accomplished efficiently by performing random walks in the volcanoes,
as described in~\cite{fouquet+morain02}. Notice that if we choose
$Δ_π$ square-free, then the only possible endomorphism ring is $\O_K$,
and this check is empty.

Concretely, for the curve of Section~\ref{sec:initcurve} $Δ_π/Δ_K=4$,
so there are exactly two possible endomorphism rings. By looking at
the action of the Frobenius endomorphism, we see that $\End(E)=\O_K$
if and only if $E[2]≃(ℤ/2ℤ)^2$.

\smallskip

Both checks can be done much more efficiently than evaluating a single
isogeny walk, thus we conclude that key validation is possible for
protocols based on the CRS construction. Contrast this with the case
of SIDH, where key validation is known to be
problematic~\cite{galbraithsecurity}, and even conjectured to be has
hard as breaking the system~\cite{cryptoeprint:2018:336}.

Thanks to key validation, we can obtain CCA-secure encryption from the
CRS action without resorting to generic transforms such as
Fujisaki-Okamoto~\cite{10.1007/3-540-48405-1_34}, unlike the case of
SIKE~\cite{SIKE,10.1007/978-3-319-70500-2_12}. This in turn enables
applications, such as non-interactive key exchange, for which no
practical post-quantum scheme was known previously to~\cite{csidh}.


\section{Experimental results}
\label{sec:exp}

In order to demonstrate that our key-exchange protocol is usable
at standard security levels, we implemented it in the Julia
programming language with the help of the computer algebra package
Nemo~\cite{todo:Nemo}. For this, we developed a small
Julia package, built upon Nemo, to handle basic functionalities
for elliptic curves over finite fields~\cite{todo:package}.
We used the Bostan--Morain--Salvy--Schost~\cite{todo:BMSS} algorithm for
isogeny computations.

In this unoptimized implementation, 
using the public parameters given in
Section~\ref{sec:initcurve},
we obtain
the following times to perform a scalar multiplication over~$\F_{q^r}$:
%todo: on which gear ?

\begin{center}
\begin{tabular}{c|ccccccc}
$r$ & 1 & 3 & 4 & 5 & 7 & 8 & 9 \\
\hline
$t\ (s)$ & 0.02 & 0.10 & 0.15 & 0.24 & 0.8 & 1.15 & 1.3
\end{tabular}
\end{center}
The time needed to factor the modular equation of level $\ell$
was approximately $0.017 * \ell$ seconds.

We can use this data to propose a maximal number of steps to be
computed for each prime. Table~\ref{tab:VéluSteps}
lists the primes for which Algorithm~\algstyle{VéluStep} can be used, with
the corresponding extension degree $r$, and a star if the twisted curve
allows to use both directions in the isogeny graph.
Table~\ref{tab:ElkiesSteps}
lists other Elkies primes for which we apply Algorithm~\algstyle{ElkiesStep}.

\begin{table}
\centering
\begin{tabular}{cclc}
$r$ & $M_\ell$ & Primes \\
\hline
1* & 409 & 3, 5, 7, 11, 13, 17, 103 \\
1 & 409 & 523, 821, 947, 1723 \\
3 & 81 & 19, 661 \\
4 & 54 & 1013, 1181 \\
5 & 34 & 31, 61, 1321 \\
7 & 10 & 547 \\
8 & 7 & 881 \\
9 & 6 & 1693
\end{tabular}
    \caption{Primes $\ell$ for which Algorithm~\algstyle{VéluStep} can be
    used for our candidate isogeny graph,
    with corresponding $r$-values and proposed bounds $M_\ell$}
    \label{tab:VéluSteps}
\end{table}

\begin{table}
\begin{tabular}{cl}
$M_\ell$ & Primes \\
\hline
20 & 23  \\
16 & 29  \\
12 & 37  \\
11 & 41  \\
10 & 43  \\
9  & 47  \\
6  & 71, 73  \\
5  & 89  \\
4  & 107,109,113  \\
3  & 131, 151  \\
2  & 157, 163, 167, 191,
     193,
     197,
     223,
     229  \\
1 &  241,
     251,
     257,
     277,
     283,
     293,
     307,
     317,
     349,
     359,
     373,
	\\ &
     383,
     401,
     421,
     431,
     433,
     439,
     443,
     449,
     457,
     467 \\
\end{tabular}
    \caption{Primes $\ell$ for which Algorithm~\algstyle{ElkiesStep} can be
    used for our candidate isogeny graph, with proposed bounds $M_\ell$}
    \label{tab:ElkiesSteps}
\end{table}


These numbers were found using the following procedure: given a maximum time
$T$ that one is willing to spend for each prime, one can compute the
associated key space size using the timing estimations above. Simply keep
increasing $T$ until a sufficiently big key space size is reached.
Using this data, we estimate the cost of a single walk in the
isogeny graph to be approximately ... seconds, bringing the global
key-exchange cost to ... seconds. We stress the fact that this implementation
is \emph{not} optimised: in particular, using an optimised C library
for the computation of $X^q$ modulo a polynomial could instantly bring a
gain by a factor at least 2.


\section{Conclusion}

- A quel point a-t-on accéléré le cryptosystème ?
- Ce protocole a-t-il finalement un intérêt dans le cadre de la crypto post-quantique ?


\bibliographystyle{plain}
\bibliography{refs}

\end{document}

%  LocalWords:  Rostovtsev Stolbunov isogenies morphism isogeny
%  LocalWords:  isomorphism coprime isogenous endomorphism bijection
%  LocalWords:  Endomorphisms cryptosystem Elkies Frobenius torsor
%  LocalWords:  Couveignes isomorphisms undirected Schreier
