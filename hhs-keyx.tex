\documentclass{article}

\usepackage{amssymb, amsmath, amsthm}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{unicode}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[ruled, vlined, linesnumbered]{algorithm2e}
\SetEndCharOfAlgoLine{}
\SetKwInput{Params}{Public parameters}
\SetKwInput{Key}{Shared key}
\SetKwInput{Input}{Input}
\SetKwBlock{Alice}{Alice}{}
\SetKwBlock{Bob}{Bob}{}
\SetKw{Samples}{samples}
\SetKw{Sends}{sends}

%Shortcuts
\newcommand{\F}{\mathbb{F}}
\newcommand{\Fbar}{\overline{\mathbb{F}}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Cl}{\mathcal{C}}
\newcommand{\Graph}{\mathcal{G}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\softO}{\tilde{O}}
\newcommand{\isom}{\overset{\sim}{\longrightarrow}}
\newcommand{\from}{\ensuremath{\,:\ }}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\suchthat}{\,\middle\vert\,}
\newcommand{\algstyle}[1]{\textsc{#1}}
\renewcommand{\v}{\vspace{5mm}}
\renewcommand{\frak}{\mathfrak}
\newcommand{\rand}[1]{\overset{#1}{∈}}
\newcommand{\uni}{\rand{R}}
\newcommand{\Adv}[2][]{\mathsf{Adv}^{#1}_{\text{\rm #2}}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{prob}[theorem]{Problem}
\newtheorem{remark}[theorem]{Remark}

\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Card}{Card}
\DeclareMathOperator{\Ell}{Ell}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\Proba}{Pr}

\title{Towards practical key exchange from ordinary isogeny graphs}
\author{Luca De Feo, Jean Kieffer, Benjamin Smith}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\textbf{Keywords:} Public-key cryptography, elliptic curve isogenies,
complex multiplication, modular curves.

\section{Introduction}
\label{sec:introduction}

A recent trend in cryptography is the development of quantum-safe
cryptosystems: protocols based on mathematical problems not known to
be solvable in polynomial time by quantum computers. With Shor's
algorithm~\cite{shor1994algorithms} ruling out systems based on
integer factorization or discrete logarithms, NIST has launched a
process to standardize the next generation of \emph{post-quantum}
public key cryptosystems~\cite{NIST2016}. In response, NIST has
received 69 proposals, most of them belonging to the three more
popular post-quantum families: lattice-based systems, code-based
systems, and multivariate systems. Among the youngest and least
explored families, \emph{isogeny-based} cryptography features only one
proposal to the NIST competition: the Supersingular Isogeny Key
Encapsulation (SIKE)~\cite{SIKE}.

SIKE is based upon the key-exchange protocol by Jao and De
Feo~\cite{jao+defeo2011}, known as SIDH, itself inspired by earlier
key-exchange constructions by Couveignes~\cite{cryptoeprint:2006:291}
and Rostovtsev and
Stolbunov~\cite{rostovtsev+stolbunov06,stolbunov-red,Stol}. The
origins of isogeny-based cryptography can be traced back to
Couveignes' seminal work ``Hard Homogeneous Spaces'', that went
unpublished for ten years before appearing
in~\cite{cryptoeprint:2006:291}. Let $G$ be a group, a \emph{principal
  homogeneous space} for $G$ is a set $X$ with an
action of $G$ on $X$ such that for any $x∈X$ the map $φ_x:g↦g·x$ is an
isomorphism between $G$ and $X$. Intuitively, one can think of $X$ as
a \emph{copy} (or, rather, \emph{many different copies}) of $G$ where
the information on the identity element has been forgotten. Couveignes
defines a \emph{hard homogeneous space} (HHS) to be a principal
homogeneous space where computing
the action of $G$ on $X$ is computationally feasible, but inverting
the isomorphism $φ_x$ is computationally hard for any $x$. 
Given a HHS $X$, we can immediately build a Diffie--Hellman type of key exchange
where the elements of $X$ are used as \emph{labels} to \emph{mask} the
group elements; then, the security of the scheme relies not (only) on
the discrete logarithm problem of $G$, but rather on the hardness of
inverting the isomorphisms $φ_x$.

Couveignes viewed HHS chiefly as a general framework, encompassing
various flavors of Diffie--Hellman-like systems. Nevertheless, he
suggested using a specific HHS based on the theory of complex
multiplication of elliptic curves, in a sense generalizing to the HHS
framework the class-group-based Diffie--Hellman key exchange of
Buchmann and Williams~\cite{Buchmann1988}. It is however Rostovtsev
and Stolbunov who first gave in~\cite{rostovtsev+stolbunov06} a
concrete and detailed realization of Couveignes' idea.

Rostovtsev and Stolbunov advertised their system as a potential
post-quantum candidate, leading Childs, Jao and Soukharev to introduce
the first subexponential quantum algorithm capable of breaking
it~\cite{childs2014constructing}. Hence, being already slow enough to
be impractical in a classical security setting, the
Rostovtsev--Stolbunov system became even more unusable in a quantum
security setting. This led Jao and De Feo to create the SIDH
key-exchange protocol~\cite{jao+defeo2011}, which to the present day
is not victim to any subexponential attack.

The aim of the present paper is to improve and modernize the
Couveignes-Rostovtsev--Stolbunov construction, borrowing techniques
from SIDH and point-counting algorithms, to the point of making it
usable in a post-quantum setting. Although the final result is far
from being practical, we believe it constitutes progress in the
direction of having a valid isogeny-based alternative to SIDH.
Furthermore, our proposed scheme presents some distinct advantages
over SIDH, that we shall discuss in Section~\ref{todo}. While
preparing this paper we were informed of
% todo: say something on CSIDH

The paper is structured as follows.
% todo

\section{Isogenies and complex multiplication}
\label{sec:math}

We recall here basic facts on isogenies of elliptic curves defined
over finite fields. For an in depth introduction to these concepts, we
refer the reader to~\cite{silverman:elliptic}, and for a general
overview of isogenies and their use in cryptography we
suggest~\cite{defeo2017isogenybased}.

In what follows $\F_q$ is a finite field of characteristic $p$ with
$q$ elements, and $\Fbar_q$ is its algebraic closure. Let $E$ and $E'$
be elliptic curves defined over $\F_q$. An isogeny $ϕ:E→E'$ is a
non-constant algebraic map sending the identity point of $E$ to
the identity point of $E'$; it induces a group homomomorphism from
$E(\Fbar_q)$ to $E'(\Fbar_q)$~\cite[III.4]{silverman:elliptic}. The
degree of an isogeny is its degree as an algebraic map; 
an isogeny of degree $ℓ$ is called an $ℓ$-isogeny.
The kernel of an isogeny,
denoted by $\ker ϕ$, is the set of points of $E(\Fbar_q)$ that is
sent to the identity point of $E'$. 
An isogeny $ϕ$ is \emph{cyclic} 
if $\ker ϕ$ is a cyclic group.

An isogeny from a curve $E$ to itself is called an
\emph{endomorphism}.
% FIXME: need to include [0] (...otherwise End(E) isn't a ring!)
Endomorphisms with the operations of addition
and composition form a ring, called the \emph{endomorphism ring} of
$E$ and denoted by $\End(E)$. Besides scalar multiplications, the
simplest example of an endomorphism is the \emph{Frobenius map}
\begin{align*}
  π : E &→ E,\\
  (x,y) &↦ (x^q,y^q).
\end{align*}
As an element of $\End(E)$, it satisfies a quadratic equation
$π^2 + q = tπ$, where the integer $t$, called the \emph{trace} of $π$,
fully determines the order of $E$ as $\#E(\F_q)=q+1-t$. A curve is
called \emph{supersingular} if $p$ divides $t$, \emph{ordinary}
otherwise.

Any isogeny can be factored as a composition of a \emph{separable} and
a \emph{purely inseparable} isogeny. \emph{Purely inseparable}
isogenies have trivial kernel, and degree a power of
$p$. \emph{Separable} isogenies contain all
isogenies of degree coprime to $p$, and
are in one-to-one correspondence with
their kernels: for any finite subgroup $G⊂E$ of order $ℓ$ there is a
unique elliptic curve up to isomorphism, denoted by $E/G$, and a
unique $ℓ$-isogeny $ϕ:E→E/G$ up to composition by the same
isomorphism, such that $\kerϕ=G$. In particular $\deg ϕ=\#\ker ϕ$. It follows
that any isogeny of degree greater than $1$ can be factored as a
composition of cyclic isogenies of prime degree.

For any $ℓ$-isogeny $ϕ:E→E'$, there is a unique $ℓ$-isogeny
$\hat{ϕ}:E'→E$ such that the compositions $ϕ∘\hat{ϕ}$ and $\hat{ϕ}∘ϕ$
are equal to the multiplication-by-$ℓ$ maps on $E'$ and $E$
respectively. $\hat{ϕ}$ is called the \emph{dual isogeny} to $ϕ$. This
shows that being \emph{$\ell$-isogenous} is an equivalence
relation. Further, a theorem of Tate states that two curves are
isogenous over $\F_q$ if and only if they have the same number of
points over $\F_q$.


\subsection{Isogeny graphs}

In isogeny-based cryptography one is mostly interested in
\emph{isogeny graphs}: (multi)-graphs whose vertices are
elliptic curves up to isomorphism, and whose edges are isogenies
between them (again up to isomorphism).
The study of isogeny graphs was initiated by
Kohel~\cite{kohel} and continued by many
authors~\cite{Gal,fouquet+morain02,GHS,MiretMSTV06,jao+miller+venkatesan09}.
Because of the dual isogeny theorem, isogeny graphs are typically
considered undirected.

We denote by $E[ℓ]$ the subgroup of $ℓ$-torsion points of
$E(\Fbar_q)$.  If $ℓ$ is coprime to $p$, then $E[ℓ]$ is isomorphic to
$(ℤ/ℓℤ)^2$.  Furthermore, if $ℓ$ is prime $E[ℓ]$ contains exactly
$ℓ+1$ cyclic subgroups of order $ℓ$; it follows that, over $\Fbar_q$,
there are exactly $ℓ+1$ distinct (separable) $ℓ$-isogenies starting
from $E$.  Generically, a connected component of the isogeny graph of
$ℓ$-isogenies over $\Fbar_q$ will be an infinite $(ℓ+1)$-regular
graph; a notable exception is the finite connected component of
\emph{supersingular} curves, used in SIDH and related protocols.

If one restricts to isogenies \emph{defined over $\F_q$}, the picture
becomes more complex.  By definition, an isogeny $ϕ:E→E'$ is
\emph{defined over} $\F_q$ if and only if the Frobenius endomorphism
$π$ stabilizes $\ker ϕ$. If $ϕ$ is cyclic, this is equivalent to
saying that $π$ acts like a scalar on the points of $\ker ϕ$.  Thus,
for any prime $ℓ≠p$, the number of outgoing $ℓ$-isogenies from $E$ is
totally understood by looking at how $π$ acts on $E[ℓ]$. Since $E[ℓ]$
is a $ℤ/ℓℤ$-module of rank $2$, the action of $π$ is represented by a
$2×2$ matrix with entries in $ℤ/ℓℤ$ and characteristic polynomial
$X^2-tX+q\mod ℓ$. We then have four possibilities:
\begin{itemize}
\item[(0)] $π$ has no eigenvalues in $ℤ/ℓℤ$, i.e.\ $X^2-tX+q$ is
  irreducible modulo $ℓ$; then $E$ has no $ℓ$-isogenies.
\item[(1.1)] $π$ has one eigenvalue of (geometric) multiplicity one,
  i.e.\ it is conjugate to a non-diagonal matrix
  $\left(\begin{smallmatrix}λ&*\\0&λ\end{smallmatrix}\right)$; then
  there is one $ℓ$-isogeny from $E$.
\item[(1.2)] $π$ has one eigenvalue of multiplicity two, i.e.\ it acts
  like a scalar matrix
  $\left(\begin{smallmatrix}λ&0\\0&λ\end{smallmatrix}\right)$; then
  there are $ℓ+1$ isogenies of degree $ℓ$ from $E$.
\item[(2)] $π$ has two distinct eigenvalues, i.e.\ it is conjugate to a
  diagonal matrix
  $\left(\begin{smallmatrix}λ&0\\0&μ\end{smallmatrix}\right)$
	with $\lambda\neq\mu$; then
  there are two isogenies from $E$.
\end{itemize}

If we denote by $Δ_π=t^2-4q$ the discriminant of the characteristic
equation of $π$, we see that the cases~(1.x) are only possible if $ℓ$
divides $Δ_π$.  For ordinary curves $Δ_π≠0$, thus only a finite number
of primes $ℓ$ will fall in these cases, and they will be mostly
irrelevant to our cryptosystem. Following the literature on the SEA
point-counting algorithm~\cite{schoof95,todo}, if $ℓ$ falls into
case~(0) it will be called an \emph{Atkin prime}, if it falls into
case~(2) it will be called an \emph{Elkies prime}.

We will chiefly be interested in Elkies primes. Since all curves in
the same isogeny class over $\F_q$ have the same number of points,
they also have the same trace $t$ and discriminant $d_π$.
% todo: do we frown upon bold emphasis?
\textbf{It follows that, if $ℓ$ is an Elkies prime for a curve $E$,
  the connected component of $E$ in the graph of $ℓ$-isogenies is a
  finite $2$-regular graph, i.e.\ a cycle.} In the next subsection we
introduce a group action on this cycle, and determine its size.


\subsection{Complex multiplication}

In this subsection we exclusively focus on ordinary elliptic
curves. If $E$ is an ordinary curve with Frobenius map $π$, its
endomorphism ring $\End(E)$ is isomorphic to an
\emph{order}\footnote{Here, an \emph{order} is a subring which is a
  $ℤ$-module of rank $2$.} in the quadratic imaginary field
$ℚ(\sqrt{Δ_π})$ (see~\cite[III.9]{silverman:elliptic}).  A curve such
that it endomorphism ring is isomorphic to some order $\O$ is said to
have \emph{complex multiplication by $\O$}.  For a detailed treatment
of the theory of complex multiplication,
see~\cite{lang1987elliptic,silverman:advanced}.

The ring of integers $\O_K$ of $K=ℚ(\sqrt{Δ_π})$ is its
\emph{maximal order}, i.e.\ it contains any other order of $K$.  Hence
$ℤ[π]⊂\End(E)⊂\O_K$, and there is only a finite number of possible
choices for $\End(E)$: write $Δ_π=d^2Δ_K$, where $Δ_K$ is the
discriminant of $\O_K$, then the index $[\O_K:\End(E)]$ must divide
$d=[\O_K:ℤ[π]]$.

It turns out that isogenies allow us to \emph{navigate} the various
orders. If $ϕ:E→E'$ is an $\ell$-isogeny, then one of the following
holds~\cite[Prop.~21]{kohel}:
\begin{itemize}
\item $\End(E) = \End(E')$, then $ϕ$ is said to be
  \emph{horizontal};
\item $[\End(E):\End(E')] = ℓ$, then $ϕ$ is said to be
  \emph{descending};
\item $[\End(E'):\End(E)] = ℓ$, then $ϕ$ is said to be
  \emph{ascending}.
\end{itemize}
Notice that the last two cases can only happen if $ℓ$ divides
$d^2=Δ_π/Δ_K$, and thus correspond to cases (1.x) in the previous
subsection.
% todo: do we frown upon bold emphasis?
\textbf{If $ℓ$ does not divide $Δ_π$, then $ϕ$ is necessarily
  horizontal.}

We now present a group action on the set of all curves having complex
multiplication by a fixed order $\O$; the key exchange protocol of
Section~\ref{sec:keyex} will be built on this action. Let $\frak a$ be
% todo: shall we say "invertible" ideal?
an ideal in $\End(E)≃\O$, and define the
\emph{${\frak a}$-torsion} subgroup of $E$ as
\[
E[\frak a] = \set{P\in E(\Fbar_q) \suchthat \sigma(P) = 0\ 
\text{ for all }\sigma\in\frak a}.
\]
This subgroup is the kernel of an isogeny $\phi_{\frak a}$, defined up
to composition by an isomorphism, hence the codomain of
$\phi_{\frak a}$ is well-defined up to isomorphism.  We denote this
codomain by $\frak a\cdot E$, in other words
$\frak a\cdot E = E/E[\frak a]$.  The isogeny $\phi_{\frak a}$ is
always horizontal (i.e.\ $\End(\frak a \cdot E) = \End(E)$), and its
degree is the \emph{norm} of $\frak a$ as an ideal of $\End(E)$.

Write $\Ell_q(\O)$ for the set of isomorphism classes over $\Fbar_q$
of curves with complex multiplication by $\O$, and assume it is
non-empty. It turns out that the construction above may be extended
into a group action: namely, the group of fractional ideals of
$\End(\O)$ acts on $\Ell_q(\O)$. Furthermore, principal ideals act
trivially, so that the action factors as an action of the \emph{ideal
  class group} $\Cl(\O)$ on $\Ell_q(\O)$.  The main theorem of complex
multiplication states that this action is \emph{simply transitive}. In
other terms, $\Ell_q(\O)$ is a \emph{principal homogeneous space}
under the group $\Cl(\O)$: if we fix a curve $E$ as base point,
we have a bijection
\[
\begin{aligned}
\Cl(\O) &\to \Ell_q(\O) \\
\text{Ideal class of }\frak a &\mapsto \text{Isomorphism class of }\frak a\cdot E.
\end{aligned}
\]
The order of $\Cl(\O)$ is called the \emph{class number} of $\O$, and
denoted by $h(\O)$. An immediate consequence of the theorem is that
$\#\Ell_q(\O)=h(\O)$.

Let now $ℓ$ be an Elkies prime for $E$, so far we have seen that the
connected component of $E$ in the $ℓ$-isogeny graph is a cycle of
horizontal isogenies. Complex multiplication tells us more. The
restriction of the Frobenius to $E[ℓ]$ has two eigenvalues $λ≠μ$, to
which we associate the prime ideals $\frak a=(π-λ,ℓ)$ and
$\hat{\frak a}=(π-μ,ℓ)$, both of norm $ℓ$. We see then that
$E[\frak a]$ is the eigenspace of $λ$, defining an isogeny
$ϕ_{\frak{a}}$ of degree $ℓ$. Furthermore
$\frak a\hat{\frak a} = \hat{\frak a}\frak a = (ℓ)$, implying that
$\frak a$ and $\hat{\frak a}$ are the inverse of one another in
$\Cl(\End(E))$, thus the isogeny $ϕ_{\hat{\frak a}}:\frak a·E→E$ of
kernel $(\frak a·E)[\hat{\frak a}]$ is the dual of $ϕ_{\frak a}$ (up
to isomorphism). Hence, 
% todo: more bold
\textbf{the eigenvalues $λ$ and $μ$ define two opposite
  \emph{directions} on the isogeny cycle, independently of the
  starting curve}, as shown in Figure~\ref{fig:cycle}.  Finally, the
size of the cycle is the order of $(π-λ,ℓ)$ in $\Cl(\End(E))$, thus
partitioning the set $\Ell_q(\End(E))$ into cycles of equal size.

\begin{figure}[t]
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \def\crater{7}
      \foreach \i in {1,...,\crater} {
        \begin{scope}[shorten >=0.1cm,->]
          \draw[blue!60!black] (360/\crater*\i : 1.95cm) -- (360/\crater*\i+360/\crater : 1.95cm);
          \draw[blue!60!white] (360/\crater*\i+360/\crater : 2.05cm) -- (360/\crater*\i : 2.05cm);
        \end{scope}
        \draw[blue!60!black] (360/\crater*\i+180/\crater:1.6cm) node {\small$λ$};
        \draw[blue!60!white] (360/\crater*\i+180/\crater:2cm) node {\small$μ$};
      }
      \foreach \i in {1,...,\crater} {
        \draw[fill] (360/\crater*\i:2cm) circle (2pt);
      }
    \end{tikzpicture}
    \caption{Isogeny cycle for an Elkies prime $ℓ$, with \emph{directions} associated to the Frobenius eigenvalues $λ$ and $μ$.}
    \label{fig:cycle}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \def\crater{12}
      \def\jumpa{-8}
      \def\jumpb{9}
      \def\diam{2cm}

      \foreach \i in {1,...,\crater} {
        \draw[blue] (360/\crater*\i : \diam) to[bend right] (360/\crater*\i+360/\crater : \diam);
        \draw[red] (360/\crater*\i : \diam) to[bend right] (360/\crater*\i+\jumpa*360/\crater : \diam);
        \draw[green] (360/\crater*\i : \diam) to[bend right=50] (360/\crater*\i+\jumpb*360/\crater : \diam);
      }
      \foreach \i in {1,...,\crater} {
        \pgfmathparse{int(mod(2^\i,13))}
        \let\exp\pgfmathresult
        \draw[fill] (360/\crater*\i: \diam) circle (2pt) +(360/\crater*\i: 0.4) node{$x^{\exp}$};
      }
    \end{tikzpicture}
    \caption{Schreier graph on a group $〈x〉$ of order $13$, acted
      upon by $(ℤ/13ℤ)^*$, generated by $S=\{2,3,5\}$ (respectively
      blue, red and green edges). Notice that $5$ has order $4$ modulo
      $13$, thus partitioning $〈x〉\setminus\{1\}$ into $3$ cycles of
      length $4$.}
    \label{fig:cayley}
  \end{minipage}
\end{figure}

\section{Key exchange from isogeny graphs}
\label{sec:keyex}

In this section, following Couveignes~\cite{cryptoeprint:2006:291} and
Rostovtsev and Stolbunov~\cite{rostovtsev+stolbunov06}, we describe a
key exchange protocol based on the action of a class group on an
isogeny graph.  This is essentially the Rostovtsev--Stolbunov key
exchange protocol, with the twist of taking advantage of specially
selected parameters to improve efficiency.

Any principal homogeneous space $X$ for a finite Abelian group $G$ can
be used to construct a key exchange as follows:

\begin{algorithm}
  \caption{Generic key exchange from a hard homogeneous space}
  \label{proto:hhs}
  \Params{A \emph{base point} $x_0∈X$}
  \Alice{
    \Samples a random element $a∈G$\;
    \Sends $x_a = a·x_0$ to Bob}
  \Bob{
    \Samples a random element $b∈G$\;
    \Sends $x_b = b·x_0$ to Alice}
  \Key{$a·x_b = b·x_a = ab·x_0$}
\end{algorithm}

If $X$ is a cyclic group $〈x〉$ of order $p$, and $G=ℤ/pℤ$ acting on
$X$ by $g·x=x^g$, then this is simply the Diffie--Hellman key exchange:
security is based on the difficulty of the discrete logarithm problem
in $X$.

More generally, if $X$ is a \emph{hard homogeneous space}, i.e.\ one
such that given $x,y∈X$ it is hard to find $g∈G$ such that $g·x=y$,
then the security of the protocol relies on a new assumption. Similar
ideas have repeatedly appeared in the literature under different
flavors~\cite{10.1007/3-540-44598-6_10,monico2007}.

We would like to apply this idea to the principal homogeneous space
$\Ell_q(\O)$ for the class group $\Cl(\O)$, for some well chosen order
$\O$ in a quadratic imaginary field. However, given a generic element
of $\Cl(\O)$, the best algorithm~\cite{jao+soukharev10} to evaluate
its action on $\Ell_q(\O)$ has subexponential complexity in $q$,
making Algorithm~\ref{proto:hhs} infeasible. The solution is to use a
special \emph{smooth} representation for the elements of $\Cl(\O)$,
that is best explained by looking at Cayley graphs.


\subsection{Key exchange from Abelian Cayley graphs}

Let $G$ be a group, $S⊂G$ a subset, and $X$ a principal homogeneous
space for $G$. We define $\Graph(G, S, X)$ as the oriented graph which
vertices are the elements of $X$, and where an edge labelled by $s∈S$
links $x_1$ to $x_2$ if and only if $s\cdot x_1 = x_2$.  If is $S$ is
symmetric (i.e.\ $S^{-1}=S$), we associate the same label to $s$ and
$s^{-1}$, and make the graph an undirected one. Such a graph is
isomorphic to the Cayley graph of $G$ generated by $S$, and is
sometimes called a \emph{Schreier graph}.  Figure~\ref{fig:cayley}
shows an example of Schreier graph where $G=(ℤ/13ℤ)^*$, $S=T∪T^{-1}$
where $T=\{2,3,5\}$, and $X$ is a cyclic group of order $13$ generated
by an element $x$, minus the identity element; the action of $G$ on
$X$ is given by exponentiation: $g·x=x^g$.

A \emph{walk} in a graph $\Graph(G,S,X)$ is a finite sequence
$(s_i)_{1≤i≤n}∈S^*$ of \emph{steps} in $S$. We extend the action of
$G$ on $X$ to an action of $S^*$ on $X$ by defining
\[(s_i)_i·x = \left(\prod_i s_i\right)·x.\] %
Note that if $G$ is Abelian the order of the steps in $(s_i)_i$ does
not matter.

If we have a Schreier graph where $G$ is finite and Abelian, and the
action $G$ on $X$ is efficiently computable, we can define a key
exchange protocol as follows:

\begin{algorithm}
  \caption{Generic key exchange from a Cayley graph}
  \label{proto:cayley}
  \Params{A \emph{base point} $x_0∈X$}
  \Alice{
    \Samples a random walk $(a_i)_i$ in $\Graph(G,S,X)$\;
    \Sends $x_a = (a_i)_i·x_0$ to Bob}
  \Bob{
    \Samples a random walk $(b_i)_i$ in $\Graph(G,S,X)$\;
    \Sends $x_b = (b_i)_i·x_0$ to Alice}
  \Key{$(a_i)_i·x_b = (b_i)_i·x_a$}
\end{algorithm}

If Alice and Bob ensure that the random walks induce a distribution on
$X$ close to uniform (in particular, the set $S$ must generate $G$),
then this protocol is essentially equivalent to
Algorithm~\ref{proto:hhs}. In particular, following the example of
Figure~\ref{fig:cayley}, if $X$ is a cyclic group $〈x〉$ of order
$p$, acted upon by $G=(ℤ/pℤ)^*$, then this protocol is equivalent to
the Diffie--Hellman protocol on $X$.

The specialization to isogeny graphs is now evident. We take:
\begin{itemize}
\item $X=\Ell_q(\O)$ as vertex set, for well chosen $q$ and $\O$;
\item $G=\Cl(\O)$ as group acting on $X$;
\item $S$ a set of ideals of the form $(π-λ,ℓ)$, where $ℓ$ is an
  Elkies prime for the isogeny class $\Ell_q(\O)$, and $λ$ is a
  Frobenius eigenvalue for $E[ℓ]$ (i.e.\ an integer in $ℤ/ℓℤ$).
\end{itemize}
The graph $\Graph(G,S,X)$ is thus an isogeny graph, composed of many
isogeny cycles superimposed on the same vertex set $\Ell_q(\O)$,
isomorphic to a Cayley graph of $\Cl(\O)$, connected if $S$ generates
$\Cl(\O)$, looking exactly like the one in Figure~\ref{fig:cayley}.

We will call \emph{isogeny walk} a walk in this graph. The action of
an ideal $\frak s=(π-λ,ℓ)$ on an elliptic curve $E∈\Ell_q(\O)$ will be
evaluated by computing the unique isogeny $ϕ_{\frak s}:E→E'$ such that
$π(P)=λP$ for all $P∈\ker ϕ_{\frak s}$; algorithms for this operation are given
in the next subsection. The action of an isogeny walk $(\frak s_i)_i$
will be simply evaluated as the sequence of isogeny steps
$ϕ_{\frak s_i}$.

Both Couveignes' and Rostovtsev and Stolbunov's cryptosystems are
special instances of the latter protocol, differing essentially in the
way walks are sampled and evaluated. In the next subsection, we
describe our own take on the protocol.

\subsection{Sampling and evaluating isogeny walks}

In order to specialize algorithm~\ref{proto:cayley} to isogeny graphs,
Rostovtsev and Stolbunov avoid computing the order $\O$, the set $\Ell_q(\O)$
or performing arithmetic operations on ideal classes. Instead, they only
manipulate isogenies between elliptic curves. We retain this idea here.
Given an ideal $\frak s = (\pi-\lambda, \ell)$, we will compute $\phi_{\frak s}:E\to E'$
using one of two different algorithms:
\begin{itemize}
\item Algorithm~\algstyle{Step1} that uses
	\emph{modular equations}, and works with any $\frak s$;
\item Algorithm~\algstyle{Step2} that
	uses \emph{torsion points} on $E$, and is only used when
	$\lambda$ satisfies certain properties.
\end{itemize}

Rostovtsev and Stolbunov only used an analogue of~\algstyle{Step1}. Using
algorithm~\algstyle{Step2}, that is inspired from the SIDH cryptosystem and
related protocols, and analyzing its consequences on the choice of public
parameters (see Section~\ref{sec:initcurve}), is the main contribution of our work.

The cost of computing an isogeny step given by $\frak s$
varies heavily according to which algorithm is used and the values of $\lambda$
and $\ell$. Therefore, we choose to \emph{weight} the isogeny walks as
follows: for each $\frak s = (\pi-\lambda,\ell)\in S$,
we define a bound $M_\ell$ for the number of times $\frak s$
appears in the random walk given as an element of $S^*$.
For convenience, we partition the set $S$
into its symmetric part $S_{sym}$, containing those ideals $\frak s$ such that
$\frak s^{-1}\in S$, and an asymmetric part $S_{asym}$. Looking back at
Figure~\ref{fig:cycle}, if $\frak s\in S_{sym}$ then both directions
$\lambda,\mu$ are used, while if $\frak s\in S_{asym}$ then only one is
available. In practice, the existence of $S_{asym}$ is connected with the use of
algorithm~\algstyle{Step2}.

Algorithm~\ref{alg:keyex} rephrases the generic key exchange~\ref{proto:cayley}
in our particular setting. Using the same public parameters, procedure
\algstyle{KeySample} generates a list $(k_\ell)$ with $-M_\ell\leq k_\ell\leq M_\ell$
for each $(\ell, \lambda, \mu, i)\in S_{sym}$, and $0\leq k_\ell\leq M_\ell$ for
each $(\ell, \lambda)\in S_{asym}$. Procedure \algstyle{Walk} simply performs
a sequence of isogeny steps as detailed in algorithm~\ref{alg:walk}.

\begin{algorithm}
  \caption{Key exchange from an isogeny graph}
  \label{alg:keyex}
  \Params{
		\begin{itemize}
		\itemsep0em
		\item A prime power $q$ 
		\item An ordinary elliptic curve $E_0/\F_q$ with Frobenius trace $t$ 
		\item $S_{sym}$ given as a list of $(\ell, \lambda, \mu, i)$ with $i\in\{1,2\}$ 
		\item $S_{asym}$ given as a list of $(\ell, \lambda)$ 
		\item Bounds $M_\ell$
		\end{itemize}
	}
  \Alice{
    \Samples $k_A = \algstyle{KeySample}$()\;
    \Sends $E_A = \algstyle{Walk}(k_A, E_0)$ to Bob}
  \Bob{
    \Samples $k_B = \algstyle{KeySample}$()\;
    \Sends $E_B = \algstyle{Walk}(k_B, E_0)$ to Alice}
  \Key{$\algstyle{Walk}(k_A, E_B) = \algstyle{Walk}(k_B, E_A)$}
\end{algorithm}

\begin{algorithm}
	\caption{\algstyle{Walk}: an isogeny walk}
	\label{alg:walk}
	\Input{An ephemeral key $k = (k_\ell)$; an initial curve $E_I$; \newline
	public data $S_{sym}, S_{asym}$}
	$E \gets E_I$\;
	\For{$(\ell, \lambda, \mu, i)\in S_{sym}$}{
		\If{$k_\ell\geq 0$}{
			\lFor{$1\leq j \leq k_\ell$}{$E\gets \algstyle{Step}i(E, \ell, \lambda)$}
		}
		\Else{
			\lFor{$1\leq j \leq |k_\ell|$}{$E\gets \algstyle{Step}i(E, \ell, \mu)$}
		}
	}
	\For{$(\ell,\lambda)\in S_{asym}$}{
		\lFor{$1\leq j \leq k_\ell$}{$E\gets \algstyle{Step2}(E, \ell, \lambda)$}
	}
\end{algorithm}

We now describe how isogeny steps are computed. Let $E$ be an elliptic
curve over $\F_q$ and $\ell$ an Elkies prime for $E$, with Frobenius
eigenvalues $\lambda,\mu$. We would like to compute an $\ell$-isogeny
step from $E$ in direction $\lambda$, i.e. the isogeny $\phi_{\frak s}$
for $\frak s = (\pi-\lambda, \ell)$.

\paragraph{Algorithm~\algstyle{Step1}.} This classical algorithm makes use
of so-called modular equations to compute isogenies between elliptic
curves. More specifically, we use the \emph{classical modular polynomial}
$\Phi_\ell(X, Y)$~\cite{todo:classicalmodpoly}.
This bivariate polynomial with integer coefficients has
the following property: a cyclic $\ell$-isogeny exists between two elliptic
curves $E$ and $E'$ if and only if $\Phi_\ell(j(E), j(E')$ = 0,
where $j$ denotes the $j$-invariant. Thus, the roots
of the polynomial equation $\Phi_\ell(j(E), X)=0$ give the two neighbors
of $E$ in the cycle of $\ell$-isogenies. The degree of this equation
is $\ell+1$.

Using this idea, when one picks a new prime $\ell$ and starts a sequence
of isogeny steps in direction $\lambda$, only one of the two neighbors is
correct. To determine which, choose one of them at random and
compute the \emph{kernel} $K$ of the corresponding $\ell$-isogeny. Several
algorithms have been designed for this purpose~\cite{todo:isogkernel}.
We then check whether the eigenvalue of $\pi$ on $K$ is indeed $\lambda$
by performing a scalar multiplication on the ``generic'' point of $K$.
This computation is only necessary for the \emph{first} $\ell$-isogeny
step, since no return on the isogeny cycle is allowed.

In practice, we store modular equations with coefficients already reduced
in $\F_q$. Several publicly available databases of modular polynomials
exist~\cite{todo:modulardatabases}. The size of the classical modular polynomial
$\Phi_\ell$ mentioned above grows quickly with $\ell$, hence it is convenient
to use other types of modular equations when $\ell$ grows, such as the so-called
Atkin modular equations~\cite{todo:atkinmodpoly}. One then has to
modify the kernel computation accordingly~\cite{todo:isogkernelatkin}.

The costly step in algorithm~\algstyle{Step1} is computing the roots
of the polynomial $\Phi_\ell(j(E), X)$. Using a Cantor--Zassenhaus-type
algorithm~\cite{todo:canzass}, this amounts to computing $X^q$ modulo
this polynomial. Using asymptotically fast methods for polynomial
arithmetic, the cost is $\softO(\ell\log q)$ field operations.

\paragraph{Algorithm \algstyle{Step2}.} This algorithm, very different
in spirit from algorithm~\algstyle{Step1}, is given by the following
pattern:
\begin{itemize}
\item Find a nonzero $Q\in \ker \phi_{\frak s}$,
\item Recover $\ker \phi_{\frak s}$ entirely by enumerating the multiples of $Q$,
\item Compute the image of $\phi_{\frak s}$ from its kernel using
Vélu's formulas~\cite{todo:velu}.
\end{itemize}
In order to find a nonzero element in $\ker\phi_{\frak s}$, we make the
following hypothesis: \emph{the multiplicative order of $\lambda$ in
$\Z/\ell\Z$ is $r$, and the multiplicative order of $\mu$ does not
divide $r$}. Then, $\ker\phi_{\frak s}$ is exactly the set of $\ell$-torsion
points on $E$ that are defined over $\F_{q^r}$. Let $C_{ext}$ be the
order of $E(\F_{q^r})$, which can be quickly computed from the
Frobenius trace $t$~\cite{todo:hasseext}.
We proceed as follows:
\begin{itemize}
\item Pick a random point $P\in E(\F_{q^r})$,
\item Compute $Q = \left[\frac{C_{ext}}{\ell}\right]P$,
\item If $Q = 0$ restart, else return $Q$.
\end{itemize}
The probability that more than one scalar multiplication will be computed
is only $\frac{1}{\ell}$.

When $\ell$ is not too large, the cost is dominated by that of the scalar
multiplication. Using asymptotically fast arithmetic operations,
the overall cost is $\softO(r^2\log q)$ field operations, as $C_{ext}$
has the same order of magnitude as $q^r$. Since the scalar
multiplication dominates, algorithm~\algstyle{Step2} can be improved
by using elliptic curve models with more efficient arithmetic~\cite{todo:curvearith}.

Note that when $r = 1$
(i.e. $\lambda = 1$), we saved a factor $\ell$ over algorithm \algstyle{Step1},
in addition with much better constant factors. As a general rule,
algorithm \algstyle{Step2} is more efficient when $r$ is small, while
for generic values of $r$ (typically $O(\ell))$ algorithm~\algstyle{Step1}
should be preferred.



Even if the multiplicative orders of $\lambda$ divides that of $\mu$,
we can still try to use algorithm \algstyle{Step2} in both directions.
The trick is to use the \emph{twisted} curve of $E$. While this does not
change the isomorphism class of the curve, the Frobenius eigenvalues
become $-\lambda$ and $-\mu$. For example, if
$p = -1\mod\ell$ and $\lambda = 1$, then $\mu=-1$ and algorithm
\algstyle{Step2} can be used in both directions with $r=1$.


It is now evident that the choice of public parameters, especially
the initial curve $E_0$, has heavy impact on the execution time:
smaller Elkies primes,
and smaller multiplicative orders of the Frobenius eigenvalues, will
lead to better practical performances. Since all this information
is contained in the value of $\# E(\F_q)$, we now face the problem
of constructing ordinary elliptic curves with prescribed
order, or more precisely with prescribed order \emph{modulo small
primes}. Unfortunately, and in contrast with the case of
supersingular curves, no polynomial-time method to achieve this 
is known in general (we will see in Section~\ref{sec:sec} why
we cannot use the CM method).
In the next section, we present our methods to find the best possible
public parameters in reasonable time.

\section{Public parameter selection}
\label{sec:initcurve}

% todo: put here remark on uselessness of complex multiplication method

In this section, we describe how to use the Schoof--Elkies--Atkin (SEA) point counting
algorithm with early abort, combined with the use of certain modular curves,
to construct curves whose cardinality satisfies some constraints
modulo small prime.
This is faster than choosing curves at random and computing their cardinalities
completely until a convenient one is found, but still does not allow us
to use the full power of algorithm~\algstyle{Step2}.

The SEA algorithm~\cite{schoof95,todo} is a polynomial-time algorithm for
point counting on elliptic curves over a finite field. In order to compute
$C = \# E(\F_p)$, it computes the value of $C\mod\ell$ modulo a series
of small primes $\ell$: it is a \emph{multimodular algorithm}.
Cryptographers are usually interested in generating elliptic curves of
prime or nearly prime order. In this case, one uses an \emph{early-abort}
mechanism: when $C = 0\mod\ell$ for some $\ell$, the algorithm is aborted
and a new curve is chosen.

Here, the situation is the opposite: we rather want elliptic curves
whose cardinality has lots of small factors. To fix ideas, let us choose
\[
p = 7 \left(\prod_{2\leq\ell\leq 380,\ \ell \text{ prime}} \ell\right) - 1
\]
which is a 512-bit prime. Then, algorithm~\algstyle{Step2} can be used
for $\ell$-isogenies with $r=1$ in both directions if and only if
$C_0 = \# E_0(\F_p)$ satisfies $C=0\mod\ell$.

We now proceed as follows:
\begin{itemize}
\item Choose a smoothness bound $B$ (we used $B = 13$).
\item Pick elliptic curves at random in $\F_p$, and use the SEA
algorithm, aborting when any $\ell\leq B$ with $C\mod\ell\neq 0$
is found.
\item For each curve which passed the tests above, complete the SEA
algorithm and estimate the key exchange running time using this
curve as a public parameter (see Section~\ref{sec:exp}).
\end{itemize}
The ``fastest'' curves are now good candidates for the curve $E_0$.

Considering the efficiency of this procedure, it is important to remark
that very few curves will pass the early-abort tests. The bound $B$ is
chosen to balance the overall cost of the first few tests with that of
the complete SEA algorithm for the curves which pass them. Therefore,
its value is somewhat implementation-dependant. In practice, one also
incorporates the test of existence of a Montgomery model for the
elliptic curve as in~\cite{todo:refMontgomery}.

Since we are looking for curves with smooth cardinalities, another
improvement to this procedure is available: instead of using elliptic
curves uniformly chosen at random, we pick random candidates using
an equation for the modular curve $X_1(N)$~\cite{sutherland2012constructing}.
This way, one guarantees the existence of a rational $N$-torsion point
on the elliptic curve without any further computation. In our
implementation, we used $N = 17$. This idea is used, for example,
in the procedure of selecting elliptic curves in the Elliptic Curve Method
for factoring~\cite{todo:refECM}.

We implemented this research using the Sage computer algebra system.
After 17,000 hours of CPU time, we found the elliptic curve
$
	E : y^2 = x^3 + ax + b
$
over $\F_p$ where the prime $p$ is given above, and
\[
\begin{aligned}
a =\ & 1111646484886395301540457987288261558243572147007270 \\ 
& 1808037226672236659358145861235530764279830938006566 \\
& 253824939581765595814774014481950202045501019370057,\\
b =\ & 7929994832424543515682621940590901949591050994041239 \\
& 8234989651750360146055419691525037257274779805461497 \\ 
& 90133670177545414851226849642510122057033563808087.
\end{aligned}
\]
It admits $\ell$-torsion rational points for each $\ell$ in
\[
  \{3, 5, 7, 11, 13, 17, 103, 523, 821, 947, 1723\}
\]
as well as a Montgomery model, and its cardinality is
\[
\begin{aligned}
& 1203734073820884503438338397822280113709202945127019 \\ 
& 7923071397735408251586670085481138030088461790938201 \\
& 874171652771344144043268298219947026188471598838060.
\end{aligned}
\]

Other proposals for public parameters are given in~\cite{todo:memoire}.
In the sequel, we will argue that using this curve brings a 128-bit security level
in the classical as well as quantum setting, and we give running times of the whole
scheme in our implementation.

\section{Security}
\label{sec:sec}

We now address the security of our proposed scheme, and related
protocols. Intuitively, these systems rely on two assumptions:
\begin{enumerate}
\item Given two elliptic curves $E,E'$ in $\Ell_q(\O)$, it is hard to
  find a (smooth degree) isogeny $ϕ:E→E'$;
\item The distribution on $\Ell_q(\O)$ induced by the random walks
  sampled in Algorithm~\ref{alg:keyex} is computationally
  undistinguishable from the uniform distribution.
\end{enumerate}

We start by reviewing the known attacks for the first problem, both in
the classical and the quantum setting. Then, we formalize security
assumptions and give security proofs against passive adversaries.
Finally, we discuss key validation and protection against active
adversaries.

\subsection{Attacks}
\label{sec:attacks}

\paragraph{Classical attacks.}
We start by addressing the following, more general, problem:

\begin{prob}
\label{prob:isog}
  Given two ordinary elliptic curves $E,E'$ defined over a finite
  field $\F_q$, such that $\#E(\F_q)=\#E'(\F_q)$, find an isogeny walk
  $(ϕ_i)_{1≤i≤n}$ such that $ϕ_n∘\cdots∘ϕ_1(E)=E'$.
\end{prob}

This problem has been studied for some time before the emergence of
isogeny-based cryptography~\cite{Gal,GHS,galbraith+stolbunov11},
because of its applications to elliptic curve
cryptography~\cite{GHS,teske06,jao+miller+venkatesan09}.  The
algorithm with the best asymptotic complexity is due to Galbraith,
Hess and Smart~\cite{GHS}; it consists of three stages:
\begin{description}
\item[Stage 0.] Use \emph{ascending} walks to reduce to the case where
  $\End(E)=\End(E')$ is the maximal order.
\item[Stage 1.] Start two random walks from $E$ and $E'$; detect the
  moment when they collide using a Pollard-rho type of algorithm.
\item[Stage 2.] Reduce the size of the obtained walk using
  index-calculus techniques.
\end{description}

To understand Stage~0, recall that all isogenous elliptic curves have
the same order, and thus the same trace $t$ of the Frobenius
endomorphism $π$. Define the Frobenius discriminant $Δ_π=t^2-4q$, then
$\End(E)$ is contained in the ring of integers $\O_K$ of
$K=ℚ(\sqrt{Δ_π})$. Write $Δ_π=d^2Δ_K$, where $Δ_K$ is the
discriminant\footnote{$Δ_K$ is also called a \emph{fundamental
    discriminant}; it is in $\{0,1\}\bmod 4$, and either $Δ_K$ or
  $Δ_K/4$ is squarefree.} of $\O_k$, then for any $ℓ\mid d$ the
$ℓ$-isogeny graph of $E$ contains \emph{ascending} and
\emph{descending} isogenies and is sometimes referred to as a
\emph{volcano}~\cite{fouquet+morain02} (see Figure~\ref{fig:volcano}).
Ascending isogenies go from curves with smaller endomorphism rings to
curves with larger ones, and take us to a curve with $\End(E)≃\O_K$ in
$O(\log d)$ steps; they can be computed efficiently using the
algorithms
of~\cite{kohel,fouquet+morain02,ionica+joux13,defeo2016explicit},
thus, Stage~0 can be accomplished\footnote{This statement is assuming
  that all prime factors of $d$ are in $O(\log q)$, which is typically
  the case for isogeny-based protocols.}  in time polynomial in
$\log q$.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \def\crater{7}
    \foreach \i in {1,...,\crater} {
      \draw[fill] (360/\crater*\i:1cm) circle (5pt);
      \draw (360/\crater*\i : 1cm) -- (360/\crater*\i+360/\crater : 1cm);
      \foreach \j in {-1,1} {
        \draw[fill] (360/\crater*\i : 1cm) -- (360/\crater*\i + \j*360/\crater/4 : 2cm) circle (3pt);
        \foreach \k in {-1,0,1} {
          \draw[fill] (360/\crater*\i + \j*360/\crater/4 : 2cm) --
          (360/\crater*\i + + \j*360/\crater/4 + \k*360/\crater/6 : 2.5cm) circle (1pt);
        }
      }
    }
  \end{tikzpicture}
  \caption{$3$-isogeny graph (\emph{volcano}) containing the curve
    with $j(E)=607$ over $\F_{6007}$. A larger vertex denotes a larger
    endomorphism ring.}
  \label{fig:volcano}
\end{figure}

The class $\Ell_q(\O_K)$ is the smallest among all classes
$\Ell_q(\O)$ for some $\O⊂\O_K$, thus it is always interesting to
reduce to it. This justifies using curves with maximal endomorphism
ring in the definition of the protocol in
Section~\ref{sec:keyex}. Remark that, when $Δ_π$ is square-free $ℤ[π]$
is the maximal order, hence this condition is automatically satisfied.

The collision search in Stage~1 relies on the birthday paradox, thus
it has a complexity of $O(\sqrt{h})$, where $h=\#\Ell_q(\O_K)$ is the
class number of $\O_K$.  It is known that, on average,
$h(\O_K)≈0.461\cdots\sqrt{|Δ_K|}$ (see~\cite[5.10]{Cohen1993}), and,
assuming the extended Riemann hypothesis, we even have a lower bound
(see~\cite{littlewood1928class})
\[h(\O_K) ≥ 0.147\cdots\frac{(1+o(1))\sqrt{|Δ_K|}}{\log\log|Δ|}.\]
Given that $Δ_K\sim q$, we expect Stage~1 to take time $O(q^{1/4})$,
thus justifying the choice of a $q$ four times as large as the
security parameter.  Unfortunately, class numbers are notoriously
difficult to compute, the current record being the computation of
$h(\O_K)$ for a discriminant of 300
bits~\cite{10.1007/978-3-642-14081-5_15}. Computing the class
number for a discriminant of $\sim 500$ bits seems to be expensive,
albeit feasible, thus we will only rely on these heuristic arguments
to justify the security of our proposed parameters.
% todo: check this is really the latest record

Finally, Stage~2 has a complexity bounded by that of Stage~1, and
outputs an isogeny walk of size polynomial in $\log q$, it thus has no
impact on our security estimates.

\begin{remark}
  The Cohen-Lenstra heuristic~\cite{10.1007/BFb0099440} predicts that
  the odd part of $\Cl(\O_K)$ is cyclic with overwhelming
  probability; and more heuristics~\cite{10.1007/3-540-44448-3_18}
  indicate that $h(\O_K)$ is likely to have a large prime factor.
  However, there is no known way in which the group structure of
  $\Cl(\O_K)$ affect the security of our protocol, we can thus
  disregard this matter. No link between the group structure
	of $E(\F_q)$ itself and the security is known either.
\end{remark}

\paragraph{Quantum attacks.}
On a quantum computer, an attack with better asymptotic complexity is
given in~\cite{childs2014constructing}. It consists of two algorithms:
\begin{enumerate}
\item A (classical) algorithm that takes as input an elliptic curve
  $E∈\Ell_q(\O)$ and an ideal $\frak a∈\Cl(\O)$, and outputs the curve
  $\frak a·E$;
\item A generic quantum algorithm for the dihedral hidden subgroup
  problem (dHSP), based upon previous work of Kuperberg~\cite{Kup} and
  Regev~\cite{regev04}.
\end{enumerate}

The ideal evaluation algorithm has sub-exponential complexity
$L_q(\frac{1}{2},\frac{\sqrt{3}}{2})$.  The dHSP algorithm uses the
ideal evaluation algorithm as a (quantum) black box, the number of
queries depending on the variant:
\begin{itemize}
\item Kuperberg's algorithm uses $O(2^{\sqrt{\log q}})$ queries, and a
  storage of $O(2^{\sqrt{\log q}})$ qubits;
\item Regev's algorithm has worse query complexity, using
  $L_q(\frac{1}{2},1)$ calls to the black box, but only requires a
  storage of $\poly(\log q)$ qubits.
\end{itemize}

Based on these estimates, we expect the bit size of $q$ to grow at
worst like the square of the security parameter. However, given that
the constants implied in the complexities are not made explicit, it is
hard to estimate the impact of this attack at concrete security levels
such as those required by NIST~\cite{NIST2016}. Nevertheless, we
remark that the weaker version of Kuperberg's algorithm described
in~\cite[§2.1]{regev04}, requires about $2^{\sqrt{8\log q}}$ queries
to the black box; this number can be taken as a very conservative
lower bound, given that the described algorithm is specific to
$h(O_K)=2^n$, and also because Regev's algorithm, with its polynomial
storage requirement, is a much more realistic candidate to run on a
real world quantum computer. By taking into account the fact that each
black box query runs a quantum circuit of subexponential size itself,
we estimate that the lower bound on the number of quantum gates is at
least the square of the lower bound on the number of quantum
queries. Based on these observations, we propose in
Table~\ref{tab:sizes} parameter sizes matching three of the NIST
categories~\cite{NIST2016}.

\begin{table}
  \renewcommand{\arraystretch}{1.4}
  \centering
  \begin{tabular}{c | c | c | c | c | c}
    $\log Δ_π$ & $\log h(\O_K)$
    & \parbox{10ex}{\centering classical security}
    & \parbox{10ex}{\centering quantum queries}
    & \parbox{10ex}{\centering quantum security}
    & \parbox{10ex}{\centering NIST category}\\
    \hline
    $512$  & $256$ & $2^{128}$ & $> 2^{64}$ & $2^{128}$ & 2\\
    $768$  & $384$ & $2^{192}$ & $> 2^{78}$ & $> 2^{156}$ & 3\\
    $1024$ & $512$ & $2^{256}$ & $> 2^{90}$ & $> 2^{180}$ & 5
  \end{tabular}
  \caption{Suggested parameter sizes at different security levels.}
  \label{tab:sizes}
\end{table}

According to this table, the public parameters we proposed
in Section~\ref{sec:initcurve} fit in NIST category 2.
Indeed, for this curve, the discriminant $\Delta_\pi$ 
has the following prime factorization:
\[
\begin{aligned}
& -2^5 \cdot 20507 \cdot 67429 \cdot 11718238170290677 \cdot 12248034502305872059 \\
& \cdot 60884358188204745129468762751254728712569\\
& \cdot 68495197685926430905162211241300486171895491480444062860794276603493,
\end{aligned}
\]
hence $\Delta_K$ is a 511-bit integer.

\subsection{Security proofs}
\label{sec:proofs}

We now formalize the assumptions needed to prove the security of the
key exchange protocol, and other derived protocols such as PKEs and
KEMs, in various models. Given the similarity with the classical
Diffie--Hellman protocol on a cyclic group, our assumptions will be
mostly modeled after those used in that context. Here we are
essentially following the lead of
Couveignes~\cite{cryptoeprint:2006:291} and
Stolbunov~\cite{Stol,Stolbunov2012}, however we take their analyses a
step further by explicitly modeling the hardness of distinguishing
random walks on Cayley graphs from the uniform distribution; this
yields stronger proofs and a better separation of security concerns.

We will write $x\rand{σ} X$ for an element taken from a set $X$
according to a probability distribution $σ$; if $X$ is finite, we
write $x\uni X$ for an element taken according to the uniform
distribution.

For the rest of the section, $q$ is a prime power, $\O$ is an order in
a quadratic imaginary field with discriminant $Δ\sim q$, $\Cl(\O)$ is
the class group of $\O$, $\Ell_q(\O)$ is the (non-empty) set of
elliptic curves with complex multiplication by $\O$, and $E_0$ is a
fixed curve in $\Ell_q(\O)$. Finally, $S$ is a set of ideals of $\O$
with norm polynomial in $\log q$, and $σ$ is a probability
distribution on $S^*$, used to sample secrets in the key exchange
protocol.

The assumption needed to prove security of the protocols is analogous
to the classical DDH assumption.

\begin{definition}[Isogeny Walk Decisional Diffie--Hellman (IW-DDH)]
  Given curves $E_a,E_b,E_{ab}∈\Ell_q(\O)$ sampled with probability
  $\frac{1}{2}$ from one of the following two distributions
  \begin{align*}
    \mathcal{R}_{q,Δ} &= \left\{\bigl((\frak a_i)_i·E_0,(\frak b_i)_i·E_0,E'\bigr) \suchthat
                        (\frak a_i)_i,(\frak b_i)_i\rand{σ}S^*,\;
                        E'\uni\Ell_q(\O)\right\},\\
    \mathcal{W}_{q,Δ,σ} &= \left\{\bigl((\frak a_i)_i·E_0,(\frak b_i)_i·E_0,(\frak a_i)·(\frak b_i)·E_0\bigr) \suchthat
                          (\frak a_i)_i,(\frak b_i)_i\rand{σ}S^*\right\},
  \end{align*}
  decide from which of the two they were sampled.
\end{definition}

We split this assumption into two more atomic assumptions. The first
states that it is computationally hard to distinguish between
commutative diagrams sampled uniformly at random, and commutative
diagrams sampled from the distribution $σ$.

\begin{definition}[Isogeny Walk Distinguishing (IWD)]
  Given curves $E_a,E_b,E_{ab}∈\Ell_q(\O)$ sampled with probability
  $\frac{1}{2}$ from one of the following two distributions
  \begin{align*}
    \mathcal{G}_{q,Δ} &= \left\{(\frak a·E_0,\frak b·E_0,\frak{ab}·E_0) \suchthat
                        \frak a,\frak b\uni\Cl(\O)\right\},\\
    \mathcal{W}_{q,Δ,σ} &= \left\{\bigl((\frak a_i)_i·E_0,(\frak b_i)_i·E_0,(\frak a_i)·(\frak b_i)·E_0\bigr) \suchthat
                          (\frak a_i)_i,(\frak b_i)_i\rand{σ}S^*\right\},
  \end{align*}
  decide from which of the two they were sampled.
\end{definition}

The second assumption is an analogue of DDH in the context of group
actions. It also appears in~\cite{cryptoeprint:2006:291} under the
name \emph{vectorization}, and in~\cite{Stol,Stolbunov2012} under the
name DDHAP.
 
\begin{definition}[Class Group Action Decisional Diffie--Hellman (CGA-DDH)]
  Given curves $E_a,E_b,E_{ab}∈\Ell_q(\O)$ sampled with probability
  $\frac{1}{2}$ from one of the following two distributions
  \begin{align*}
    \mathcal{U}_{q,Δ} &= \left\{(E_a,E_b,E_{ab}) \suchthat E_a,E_b,E_{ab}\uni\Ell_q(\O)\right\},\\
    \mathcal{G}_{q,Δ} &= \left\{(\frak a·E_0,\frak b·E_0,\frak{ab}·E_0) \suchthat
                        \frak a,\frak b\uni\Cl(\O)\right\},
  \end{align*}
  decide from which of the two they were sampled.
\end{definition}

We want to prove the security of protocols based on the primitive of
Section~\ref{sec:keyex} under the CGA-DDH and IWD assumptions
combined. To do this we give a lemma showing that CGA-DDH and IWD
together imply IW-DDH. The technique is straightforward: we use an
IW-DDH oracle to solve both the CGA-DDH and IWD problems, showing that
at least one of the two must be solvable with non-negligible
advantage. The only technical difficulty lies in the fact that we need
an efficient way to simulate the uniform distribution on $\Ell_q(\O)$;
for this, we use another Cayley graph on $\Ell_q(\O)$, potentially
with a larger edge set, that is proven
in~\cite{jao+miller+venkatesan09} to be an expander.

We let $\Adv[A]{IW-DDH}$ be the \emph{advantage} of an adversary $A$
against IW-DDH, defined as the probability that $A$ answers correctly,
minus $\frac{1}{2}$:
\[2\Adv[A]{IW-DDH} = \Proba\bigl[A(\mathcal{R}_{q,Δ}) = 1\bigr] -
  \Proba\bigl[A(\mathcal{W}_{q,Δ,σ}) = 1\bigr].\] %
We define similarly $\Adv[A]{CGA-DDH}$ and $\Adv[A]{IWD}$. By switching
answers if needed, we can assume all advantages are positive. We
denote by $\Adv{xxx}(t)$ the maximum of $\Adv[A]{xxx}$ over all
adversaries using at most $t$ resources (e.g.\ running time, queries,
etc.).

\begin{lemma}
\label{lem:adv}
  Assuming GRH, for $q$ large enough and for any bound $t$ on running
  time, and for any $\epsilon>0$,
  \[\Adv{IW-DDH}(t) ≤ 2\Adv{IWD}(t+\poly(\log q, \log\epsilon)) + \Adv{CGA-DDH}(t) + \epsilon.\]
\end{lemma}
\begin{proof}[Proof (Sketch)]
  We start with an adversary $A$ for IW-DDH, and we construct two simulators
  $S$ and $T$ for CGA-DDH and IWD respectively.

  The simulator $S$ simply passes its inputs to $A$ and returns
  whatever response $A$ gives.

  The simulator $T$ receives a triplet $(E_a,E_b,E_{ab})$ taken from
  one of $\mathcal{G}_{q,Δ}$ or $\mathcal{W}_{q,Δ,σ}$. It flips a coin
  to decide which of the two following actions it will do:
  \begin{itemize}
  \item It forwards $(E_a,E_b,E_{ab})$ to $A$, it returns the same bit
    as given by $A$;
  \item It generates a random curve $E_c∈\Ell_q(\O)$, it forwards
    $(E_a,E_b,E_c)$ to $A$, it returns the opposite bit to the one
    given by $A$.
  \end{itemize}
  
  The curve $E_c$ must be taken from a distribution close to uniform
  for the simulator to work. The only way at our disposal to sample
  $E_c$ uniformly would be to sample a uniform $\frak c∈\O$, and take
  $E_c=\frak c·E_0$, but this would be too costly. Instead we
  use~\cite[Theorem~1.5]{jao+miller+venkatesan09},
	combined with standard results about random walks in
	expander graphs, to sample $E_c$ so
  that any curve in $\Ell_q(\O)$ is taken with probability between
  % todo: Jean, you mentioned that you could get closer to the uniform
  % distribution by lengthening the walks?
  $(1-\epsilon)/h(\O)$ and $(1+\epsilon)/h(\O)$,
	using only $\poly(\log q, \log\epsilon)$ operations.
	We can consider this sampling as follows:
	with probability $1-\epsilon$, sample $E_c$ \emph{uniformly},
	and with probability $\epsilon$ sample it from
	an unknown distribution of probability.

  Now, if $T$ forwarded $(E_a,E_b,E_{ab})$ untouched, it is immediate
  to see that
  \[2\Adv[T]{IWD} = \Adv[A]{IW-DDH} - \Adv[S]{CGA-DDH},\] %
  while if $T$ forwarded $(E_a,E_b,E_c)$, then we get
  \[2\Adv[T]{IWD} \geq \Adv[A]{IW-DDH} - (1-\epsilon)\Adv[S]{CGA-DDH} - \epsilon.\] %
  Averaging over the two outcomes gives in particular
  \[2\Adv[T]{IWD} \geq \Adv[A]{IW-DDH} - \Adv[S]{CGA-DDH} - \epsilon,\] %
  concluding the proof.
\end{proof}

Finally, we give an assumption akin to the classical CDH assumption
for groups. Using the same techniques as above, we can prove the
security of the relevant protocols based only on CGA-CDH and IWD,
\emph{without GRH}.

\begin{definition}[Class Group Action Computational Diffie Hellman (CGA-CDH)]
  Given curves $E_a=\frak a·E_0$ and $E_b=\frak b·E_0$, with
  $\frak a,\frak b\uni\Cl(\O)$, compute the curve
  $E_{ab}=\frak{ab}·E_0$.
\end{definition}

We can now prove the security of our schemes. Stolbunov already proved
the security of Algorithm~\ref{proto:hhs} under the equivalent of
CGA-DDH~\cite{Stol}. By repeating the same steps, we can prove the
following theorem.

\begin{theorem}
  If the CGA-DDH and IWD assumptions hold, assuming GRH, the
  key-agreement protocol in Algorithm~\ref{alg:keyex} is session-key
  secure in the authenticated-links adversarial model of Canetti and
  Krawczyk~\cite{canetti}.
\end{theorem}

Similarly, we can prove the IND-CPA security of the hashed El Gamal
protocol derived from Algorithm~\ref{alg:keyex} by replicating the
classical techniques of, for
instance,~\cite[20.4.11]{galbraith2012mathematics}.

\begin{theorem}
  Assuming CGA-CDH and IWD, the hashed El Gamal protocol derived from
  Algorithm~\ref{alg:keyex} is IND-CPA secure in the random oracle
  model.
\end{theorem}


\paragraph{A heuristic discussion of the IWD assumption.}

From its very definition, the IWD assumption depends on
the probability distribution $\sigma$ we use to sample
random walks in the isogeny graph. In this paragraph,
we provide heuristic arguments indicating that IWD is hard
using Algorithm~\ref{alg:walk}, provided the following
two statements are true:
\begin{itemize}
\item $S$ is \emph{not too small}, i.e. the number of
isogeny degrees used is $\Omega(\log q)$;
\item Key space size is at least $\sqrt{|\Delta_K|}$.
\end{itemize}

At present, proving rapid mixing of random walks with such
parameters seems out of reach even under number-theoretic
hypotheses such as GRH. The best results available,
like~\cite[Theorem~1.5]{jao+miller+venkatesan09}
that was used in the proof of Lemma~\ref{lem:adv},
typically require isogeny degrees $\Omega((\log q)^B)$
for some $B>2$, and fully random walks that are not,
for example, weighted towards smaller-degree isogenies.

However, numerical evidence widely suggests that
such results are too weak. In~\cite[7.2]{jao+miller+venkatesan09},
it is asked whether an analogue of the previous theorem would
be true with the sole constraint $B>1$. In~\cite[Section~3]{GHS},
it is mentioned that much less split primes are needed to walk
in the isogeny graph than theoretically expected.
We believe that these experiments can bring some evidence
in relying on the IWD assumptions with more aggressive
parameters than those provided by GRH.

Regarding the weighting of random walks,
practical evidence also suggests that the rapid mixing
properties are not lost: in~\cite{galbraith+stolbunov11},
such walks are used to accelerate the algorithm
solving Problem~\ref{prob:isog}.

\subsection{Key validation and active security}



\section{Experimental results}
\label{sec:exp}

In order to demonstrate that our key-exchange protocol is usable
at standard security levels, we implemented it in the Julia
programming language with the help of the computer algebra package
Nemo~\cite{todo:Nemo}. In this occasion, we developed a small
Julia package built upon Nemo that handles basic functionalities
regarding elliptic curves over finite fields~\cite{todo:package}.
We used the Bostan--Morain--Salvy--Schost~\cite{todo:BMSS} for
isogeny computations.

We use the public parameters as given in
Section~\ref{sec:initcurve}.
In this unoptimized implementation, we obtain
the following times to perform a scalar multiplication over $\F_{q^r}$:
%todo: on which gear ?

\begin{center}
\begin{tabular}{c|ccccccc}
$r$ & 1 & 3 & 4 & 5 & 7 & 8 & 9 \\
\hline
$t\ (s)$ & 0.02 & 0.10 & 0.15 & 0.24 & 0.8 & 1.15 & 1.3
\end{tabular}
\end{center}

and the approximate time needed to factor the modular equation of level $\ell$
is $0.017 * \ell$ seconds.

Using such data, one can propose a maximal number of steps to be
computed for each prime. In the upper table of Figure~\ref{fig:steps}, we
list the primes for which algorithm~\algstyle{Step2} is used, with
the corresponding extension degree $r$, and a star if the twisted curve
allows to use both directions in the isogeny graph. In the lower table,
we list other Elkies primes for which we apply algorithm~\algstyle{Step1}.

\begin{figure}
\centering
\begin{tabular}{cclc}
$r$ & $M_\ell$ & Primes \\
\hline
1* & 409 & \{3, 5, 7, 11, 13, 17, 103\} \\
1 & 409 & \{523, 821, 947, 1723\} \\
3 & 81 & \{19, 661\} \\
4 & 54 & \{1013, 1181\} \\
5 & 34 & \{31, 61, 1321\} \\
7 & 10 & \{547\} \\
8 & 7 & \{881\} \\
9 & 6 & \{1693\}
\end{tabular}
\vfill
\begin{tabular}{cl}
$M_\ell$ & Primes \\
\hline
20 & \{23\} \\
16 & \{29\} \\
12 & \{37\} \\
11 & \{41\} \\
10 & \{43\} \\
9 & \{47\} \\
6 & \{71,73\} \\
5 & \{89\} \\
4 & \{107,109,113\} \\
3 & \{131,151\} \\
2 & \{157,163,167,191,
  193,
  197,
  223,
  229\} \\
1 & \{241,
  251,
  257,
  277,
  283,
  293,
  307,
  317,
  349,
  359,
  373,
	\\ &
  383,
  401,
  421,
  431,
  433,
  439,
  443,
  449,
  457,
  467\} \\
\end{tabular}
\caption{\label{fig:steps} A proposal for the bounds $M_\ell$}
\end{figure}

These numbers were found using the following procedure: given a maximum time
$T$ that one is willing to spend for each prime, one can compute the
associated key space size using the timing estimations above. Simply keep
increasing $T$ until a sufficiently big key space size is reached.
Using this data, we estimate the cost of a single walk in the
isogeny graph to be approximately ... seconds, bringing the global
key-exchange cost to ... seconds. We stress the fact that this implementation
is \emph{not} optimised: in particular, using an optimised C library
for the computation of $X^q$ modulo a polynomial could instantly bring a
gain by a factor at least 2.


\section{Conclusion}

- A quel point a-t-on accéléré le cryptosystème ?
- Ce protocole a-t-il finalement un intérêt dans le cadre de la crypto post-quantique ?


\bibliographystyle{plain}
\bibliography{refs}

\end{document}

%  LocalWords:  Rostovtsev Stolbunov isogenies morphism isogeny
%  LocalWords:  isomorphism coprime isogenous endomorphism bijection
%  LocalWords:  Endomorphisms cryptosystem Elkies Frobenius torsor
%  LocalWords:  Couveignes isomorphisms undirected Schreier
